/*
 *************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Gabriele Strattner <gs@suse.de>
 *
 * Purpose:
 *
 * Modify:
 *
 * external function:
 *
 *
 *************************************************************
 $Id$
*/

{
  textdomain "online_update";

  import "Mode";
  import "OnlineUpdate";
  import "InstMedia";
  import "Arch";
  
  // selected you server
  string you_server 	= Mode::youInstallMap["you_server"]:"";
  string you_serverkind = Mode::youInstallMap["you_serverkind"]:"";  
  string you_dir 	= Mode::youInstallMap["you_dir"]:"";
  
  // check installation mode
  boolean auto_mode 	= OnlineUpdate::you_auto;
  boolean continue_mode = OnlineUpdate::you_continue;
  boolean auto_mode_get = OnlineUpdate::you_auto_get;
  boolean auto_mode_install = OnlineUpdate::you_auto_install;
  boolean cd_update 	= OnlineUpdate::cd_update;
  
  // prepare for inst_rpmcopy
  Mode::normal = true;
  InstMedia::installmode = "hd";

  
  // possible status information
  string ERROR 	= "error";
  string INSTALLED = "installed";
  string LOAD 	= "load";
  
  
  //////////////////////////////////////////////////////////////////////////////
  //                                  P O P U P S                             //
  //////////////////////////////////////////////////////////////////////////////

  global define ShowProgress( integer percent )``{
      
      y2debug("PROGRESS: %1", percent );
      UI::ChangeWidget(`id(`progress), `Value, percent );
  };

  
  ///////////////////////////////////////////////////////////////////////////////
  // MAIN:
  ///////////////////////////////////////////////////////////////////////////////

  term download = nil;
  
  if ( UI::HasSpecialWidget(`DownloadProgress ) )
  {
      download = `Left(`DownloadProgress(`id(`fileProgress),_("Current patch"), "", 0 ));
  }
  else
  {
      download = `Empty();
  }

  term contents =
      // main dialog: 
      `VBox(
	    `VSpacing( 0.2 ),
	    `HBox(
		  `HWeight( 50,`VBox(`Left(`Label(_("Connected to"))),
				     `Left(`Label(`id(`id1),`opt(`outputField), "                                          "))
				      )
			    ),
		  `HWeight( 50,`VBox(`Left(`Label(_("Status of connection"))),
				     `Left(`Label(`id(`status),`opt(`outputField), "                                          "))
				      )
			    )
		  ),
	    `VSpacing(0.5),
	    download,
	    `Left(`ProgressBar(`id(`progress), _("Total progress"), 100)),
	    `LogView(`id(`log),
		     _("Information about the activities"),
		     5,		// visible lines
		     500),	// lines to store,
	    `VSpacing( 0.2 )
	    );

  
  string help_text = "";

  // helptext  "Connection and Data transfer" 
  string help_part11 =  _("<p>After connecting to SuSE server,
YaST2 will download all selected patches.
This could take some time. Several details are shown.</p>");

  string help_part12 = _("<p>YaST2 first gets the patch descriptions
from the patch CD.<br>
After that, all selected patches will be copied to the
hard disk.</p>
");

  string help_part13 = _("<p>After YaST2 retrieves the descriptions of
the available patches from the FTP or HTTP server, 
select the patches to
download and install.</p>
");
  
  string help_part2 =  _("<p>
The fields above show information about the connection and
the time for data transfer.
The box below displays data from the FTP or HTTP log file. If something
goes wrong, check this file for information. 
</p>
");
  string help_part3 =  _("<p>
If you decide to <b>Abort Update</b>, the download of
patches will be interrupted. No patch will be installed.
The FTP or HTTP connection will be closed. 
</p>
");

  if ( cd_update )
  {
      help_text = help_part12;
  }
  else if (auto_mode || continue_mode)
  {
      help_text = help_part11 + help_part2 + help_part3;
  }
  else
  {
      help_text = help_part13 + help_part2 + help_part3; 
  }

  //
  // show the dialog also for CD update (!continue_mode)
  // because it can take some time to copy the patch descriptions
  // and there could be a popup "YaST2 patches available". 
  //
  
  Wizard::SetContents(_("Connection and Data transfer"), contents, help_text, Args(0), Args(1) );

  UI::ChangeWidget(`id(`id1), `Value, you_server);  
  UI::ChangeWidget(`id(`status), `Value, _("closed") );

  // Fake getting of patches for fake_mode (NOT USED)
  integer test_id = 0;
  global define FakeGetPatch( string patch) ``{
      integer counter = 0;
      string log = "";
      map result = $[];
      
      while (counter < 100)
      {
	  counter = counter + 1;
	  UI::ChangeWidget(`id(`log), `LastLine, "Neue Zeile ........\n" );
      }
      test_id = test_id + 1;
	 
      y2debug("ONLINE: Get patch %1 ( fake_mode ): %2", patch, test_id != 3 );

      if (test_id == 3)
      {
	  result = add(result, "ok", false );
	  string msg =  sformat( "Download failed for patch %1.\nReasons are unknown.", patch );
	  result = add( result, "message", msg );
      }
      else
      {
	  result = add(result, "ok", true );
	  string msg = sformat("Download successful for patch %1.\n", patch );
	  result = add( result, "message", msg );
      }
      result = add(result, "progress", test_id*10);
      result = add(result, "continue", false );
      
      return result;
  };

  // get patches from you server
  global define GetAllPatches( map new_patches ) ``{
      list ret_list = [];
      list patch_list = [];
      integer index = 0;
      boolean go_on = true;
      integer patch_no = 0;
      string batchkind = "";

      batchkind = OnlineUpdate::you_auto_batchkind;

      foreach( `patch, `patch_info, new_patches, ``{
	  // only get the patch if marked with "X" or "G" 
	  if ( select ( lookup(new_patches, patch, []), 3, "" ) == "X"
	       || select ( lookup(new_patches, patch, []), 3, "" ) == "G")
	   {
	       if ( batchkind == "all" ||
		    batchkind == select ( lookup(new_patches, patch, []), 0, "" ) )
	       {
		   patch_list = add(patch_list, patch);
	       }
	   }
      });
      patch_no = size(patch_list);

      if ( patch_no == 0 )
      {
	  // nothing will do
	  return ret_list;
      }

      string connect_string = sformat ( _("Starting download of selected patches from %1.\n"), you_server );
      UI::ChangeWidget(`id(`log), `LastLine, connect_string );

      map  result_map = SCR::Execute(.you.connect,"");
      y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result_map );
      connect_string = lookup (result_map, "message", "" );
      if ( size ( connect_string ) > 0 )
      {
	  UI::ChangeWidget(`id(`log), `LastLine, connect_string+"\n" );
      }
      if (lookup( result_map, "ok", false )  )
      {
	  UI::ChangeWidget(`id(`status), `Value, _("active"));
      }

      ShowProgress( 5 );

      string lastErrorServer = you_server; // only for error popup      
      
      while ( (index < patch_no) && go_on )
      {
	  map patch_result = $[];
	  string patch = select( patch_list, index, "" );
	  
	  y2debug("Status of patch %1: %2", patch, select( lookup(new_patches, patch, []), 3, "" ));

	  UI::ChangeWidget(`id(`log), `LastLine, sformat( _("Get packages for patch %1\n"), patch) );
	  
	  patch_result = SCR::Execute( .you.getPatch, patch );
	  y2milestone("ONLINE: SCR::Execute(.you.getPatch, %1 )): %2", patch, patch_result );
	  
	  while ( lookup(patch_result, "ok", false) == true &&
		  lookup(patch_result, "nextPackage","") != "" )
	  {
	      boolean otherServerConnect = false;
	      y2milestone("ONLINE: SCR::Execute(.you.getPatch, %1 )): %2", patch, patch_result );  

	      UI::ChangeWidget(`id(`log), `LastLine, "Package " +
			    lookup(patch_result, "nextPackage","") +
			   "\n" );
	      UI::ChangeWidget(`id(`fileProgress), `ExpectedSize, lookup(patch_result, "nextPackageSize", 0));
	      UI::ChangeWidget(`id(`fileProgress), `Filename, lookup(patch_result, "nextPackage", ""));

	      string otherYouServer = lookup ( patch_result, "nextServer", "" );
	      string otherYouServerKind = lookup ( patch_result, "nextServerKind", "" );
	      string scriptName = "";

	      if ( lookup ( patch_result, "nextSerie", "" ) == "script" )
	      {
		  scriptName = lookup(patch_result, "nextPackage","");
	      }
	      
	      // Checking, if the package is on another server; not when the
	      // source is CD, Harddisk....
	      if ( you_serverkind != "local" &&
		   you_serverkind != "Net" &&
		   you_serverkind != "CD" &&
		   you_serverkind != "Harddisk" &&
		   size ( otherYouServer ) > 0 )
	      {
		  map result = $[];

		  otherServerConnect = true;
		  
		  // disconnect from the old server
		  result = SCR::Execute( .you.disconnect,"");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", result );
		  string last_logging = lookup(result, "message", "" );
		  if ( size ( last_logging ) > 0 )
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
		  }
		  if ( lookup( result, "ok", false )  )
		  {
		      UI::ChangeWidget(`id(`status), `Value, _("closed"));
		  }
		  
		  // connecting to other you-server

		  any retval = SCR::Execute( .you.setServer,
					     $["kind":otherYouServerKind,
					      "name":otherYouServerr,
					      "path":"."]);
		  y2debug("ONLINE: SCR::Execute(.you.setServer,( %1, %2 %3 ) ): %4",
			  otherYouServer, ".", otherYouServerKind, retval );
		
		  if (retval == nil || retval == false)
		  {
		      last_logging = sformat ( _("Connection failed to %1\n"), otherYouServer );
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging );   
		  }
		  else
		  {
		      // connect to new server
		      result = SCR::Execute(.you.connect,"");
		      y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result );		      

		      string connect_string = lookup (result, "message", "" );
		      if ( size ( connect_string ) > 0 )
		      {
			  UI::ChangeWidget(`id(`log), `LastLine, connect_string+"\n" );
		      }
		      if (lookup( result, "ok", false )  )
		      {
			  UI::ChangeWidget(`id(`status), `Value, _("active"));
			  UI::ChangeWidget(`id(`id1), `Value, otherYouServer);  			  
		      }
		  }
	      }

	      // Getting rpm
	      patch_result = SCR::Execute( .you.getPatch, patch );
	      y2debug("ONLINE: SCR::Execute(.you.getPatch, %1 )): %2", patch, patch_result );
	      
	      if ( !lookup(patch_result, "ok", false)  )
	      {
		  if ( otherServerConnect )
		  {
		      lastErrorServer = otherYouServer;
		  }
		  else
		  {
		      lastErrorServer = you_server;
		  }
	      }
	      
	      if ( otherServerConnect )
	      {
		  //Reconnect to old server
		  map result = $[];

		  otherServerConnect = false;
		  
		  // disconnect from  server
		  result = SCR::Execute( .you.disconnect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", result );
		  
		  string last_logging = lookup(result, "message", "" );
		  if ( size ( last_logging ) > 0 )
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
		  }
		  if ( lookup( result, "ok", false )  )
		  {
		      UI::ChangeWidget(`id(`status), `Value, _("closed"));
		  }
		  
		  // setting to old you-server
		  any retval = SCR::Execute( .you.setServer,
					 $["kind":you_serverkind, "name":you_server, "path":you_dir]);		  
		  if (retval == nil || retval == false)
		  {
		      last_logging = sformat ( _("Connection failed to %1\n"), you_server );
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging );    
		  }

		  // connect to old server
		  result = SCR::Execute(.you.connect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result );		      		  
		  if (lookup( result, "ok", false )  )
		  {
		      UI::ChangeWidget(`id(`status), `Value, _("active"));
		      UI::ChangeWidget(`id(`id1), `Value, you_server);   
		  }
	      }

	      if ( scriptName != ""
		   && select( lookup(new_patches, patch, []), 3, "" ) == "X" )
	      {
		  string command = "source " + scriptName;
		  
		  UI::ChangeWidget(`id(`log), `LastLine, "Execute script " + scriptName + "\n");
		  
		  integer doresult = SCR::Execute (.target.bash, command );

		  if (doresult==0)
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, "return ok\n");		      
		  }
		  else
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, "return NOT ok\n");		      
		  }
	      }
	  }
	  
	  if ( !lookup(patch_result, "ok", false) )
	  {
	      // set status to error
	      SCR::Write(.you.patchUpdateStatus, patch, ERROR );
	      y2debug("ONLINE:  SCR::Write(.you.patchUpdateStatus,%1, %2)", patch, ERROR );
	      OnlineUpdate::you_ok = false;
	       
	      // put logging into LogView Widget before showing popup
	      string last_logging = lookup(patch_result, "message", "" );
	      if ( size ( last_logging ) > 0 )
	      {
		  UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
	      }

	      if (  !auto_mode_get )
	      {
		  string msg_str = sformat(_("Cannot get patch \"%1\" from
server \"%2\".
Try to download remaining patches or
continue with installation of downloaded ones.
"),
					   select(patch_list, index, ""), lastErrorServer );
	      
		  any ret = UI::DisplayMsgFtp( msg_str, _("Notify"), _("&Download"), _("&Install") );

		  if (!ret)
		  {
		      go_on = false;
		  }
	      }
	  }
	  else if ( select ( lookup(new_patches, patch, []), 3, "" ) == "X" )
	  {
	      // patches marked with "X" will be installed
	      if ( batchkind == "all" ||
		   batchkind == select ( lookup(new_patches, patch, []), 0, "" ) )
	      {
		  ret_list = add( ret_list, patch );
	      }
	  }
	  
	  // put logging into LogView Widget
	  string log_string = lookup(patch_result, "message", "" );
	  if ( log_string != "" )
	  {
	      UI::ChangeWidget(`id(`log), `LastLine, log_string+"\n" );
	  }

	  // Polling input to give the user a chance to stop the download  
	  any r = UI::PollInput();
	  if ( r == `abort )
	  {
	      any ret = UI::DisplayMsgFtp( _("Download of patches will be stopped.
You may continue with installation of already
loaded patches or abort update completely."), _("Warning"), _("&Install"), _("&Abort"));
	      go_on = false;

	      if ( !ret )
	      {
		  // don't install any patches - finish the workflow
		  ret_list = [];
	      }
	      // else   stop loading and continue with installation of the patches
	  }
	  index = index+1;
	  if (((index*100)/patch_no) > 95 )
	  {
	      ShowProgress( 95 );	      
	  }
	  else
	  {
	      ShowProgress( (index*100)/patch_no );
	  }
      }
      
      ShowProgress( 0 );

      UI::ChangeWidget(`id(`fileProgress), `Filename, "");      
      UI::ChangeWidget(`id(`fileProgress), `ExpectedSize, 1024);
      
      // disconnect
      map result = SCR::Execute( .you.disconnect, "");
      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", result );      

      string last_logging = lookup(result, "message", "" );
      if ( size ( last_logging ) > 0 )
      {
	  UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
      }
      if (lookup( result, "ok", false )  )
      {
	  UI::ChangeWidget(`id(`status), `Value, _("closed"));
      }
      
      return ret_list;
  };

  //
  // Checking packages for consistents and original SuSE-packages
  //
  global define checkPackages( list package_list, string patch ) ``{
      boolean install = true;
      boolean dontAsk = false;

      string tmpfile = SCR::Read(.run.mktemp);

      string gpg_warning = sformat(
				   _("Cannot check patch %1 because the GPG key is not installed or is corrupted.
SuSE cannot guarantee that the packages were created by SuSE.
"),
			       patch);

      map patchDescription = $[];
      map packageMap = $[];
      
      patchDescription = PKGINFO( `ftpGetPatchInformation(patch) );
      packageMap = lookup( patchDescription, "packages", $[] );      
      
      if ( !(SCR::Read (.targetpkg.installed, "gpg")) )
      {
	  // package gpg not found
	  gpg_warning = sformat(
		   _("Cannot check patch %1 because the GPG package is not installed or is
corrupted.
SuSE cannot guarantee that the packages were created by SuSE.
"),
		   patch);
      }
      
      y2milestone ( "tmpfile : %1", tmpfile );
      foreach ( `package, package_list, ``{
	  integer ret_shell = SCR::Execute(.target.bash,
				"/bin/rpm --checksig " + package + " >" + tmpfile + " 2>>" + tmpfile );
	  if ( ret_shell != 0 )
	  {
	      if ( SCR ::Execute (.target.bash, "/bin/grep -i \"GPG NOT OK\" " + tmpfile ) == 0 )
	      {
		  boolean ret = true;

		  y2warning ( "package %1 returned gpg-error",
				package );
		  if ( !dontAsk )
		  {
		      ret = UI::DisplayMsgYou( gpg_warning, _("Warning"),
					       _("&Install"), _("&Don't install") );
		      if ( !ret )
		      {
			  install = false;
		      }
		      else
		      {
			  y2warning ( "installing anyway" );
		      }
		      dontAsk = true;
		  }
	      }
	      else
	      {
		  string message = sformat(
					   _("Patch %1 will not be installed 
because package %2 is corrupted.
"),
					   patch, package );
	      
		  y2error( "%1", message );
	      
		  UI::DisplayMsgYouOk( message, _("Error"), _("&ok") );
		  install = false;
	      }
	  }
	  else
	  {
	      // Checking, if gpg was available
	      if ( SCR::Execute (.target.bash, "/bin/grep -i \"GPG\" " + tmpfile ) != 0 )
	      {
		  y2warning ( "package %1 no gpg-key found",
				package );
		  
		  if ( !dontAsk )
		  {
		      boolean ret = true;
		      
		      ret = UI::DisplayMsgYou( gpg_warning, _("Warning"),
					       _("&Install"), _("&Don't install") );
		      if ( !ret )
		      {
			  install = false;
		      }
		      else
		      {
			  y2warning ( "installing anyway" );
		      }
		      
		      dontAsk = true;
		  }
	      }
	  }
	  
	  SCR::Execute (.target.bash, "/bin/rm " + tmpfile );

	  // checking the correct version of the rpm
	  integer rpm_pos = findlastof ( package, "/" );	// find trailing slash
	  string packageName = "";

	  if ( rpm_pos > 0 )
	  {
	      // cut off trailing build no.
	      packageName = substring( package, rpm_pos+1, size( package )-4 -rpm_pos -1 );
	  }
	  else
	  {
	      packageName = substring( package, 0, size( package )-4 );
	  }

	  list packageList = lookup ( packageMap, packageName, [] );
	  
	  if ( size ( packageList ) > 0 )
	  {
	      y2milestone ( "Checking package %1 with version %2: %3",
			    packageName,
			    select ( packageList, 2, ""),
                            packageList );
	      
	      string command = "MYVER="+
			select ( packageList, 2, "") +
			";/usr/bin/test \"$MYVER\" = `/bin/rpm -qp --qf \"%{VERSION}-%{RELEASE}\\n\" " + package +"`";
	      y2milestone( "check-command %1", command );
	      if ( SCR (`Execute (.target.bash, command ) ) != 0 )
	      {
		  boolean ret = true;

		  y2warning ( "package %1 (%2) returned an release error",
			      package, packageName );
		  if ( !dontAsk )
		  {
		      ret = UI(`DisplayMsgFtp( "There will be not installed the correct version of the package !\nSo SuSE cannot guarantee that the patch has been created by SuSE", _("Warning"),
					       _("&Install"), _("&Don't install") ));
		      if ( !ret )
		      {
			  install = false;
		      }
		      else
		      {
			  y2warning ( "installing anyway" );
		      }
		      
		      dontAsk = true;
		  }		  
	      }
	  }
	  else
	  {
	      boolean ret = true;

	      y2warning ( "package %1 (%2) not found in the patch description",
			  package,
			  packageName );
	      if ( !dontAsk )
	      {
		  ret = UI(`DisplayMsgFtp( "There will be not installed the correct version of the package !\nSo SuSE cannot guarantee that the patch has been created by SuSE", _("Warning"),
					   _("&Install"), _("&Don't install") ));
		  if ( !ret )
		  {
		      install = false;
		  }
		  else
		  {
		      y2warning ( "installing anyway" );
		  }
		  
		  dontAsk = true;
	      }
	  }	  
      });
      
      return install;
  };

    
  //
  // InstallPatches
  // call inst_rpmcopy for every patch with list of packages belonging to the patch
  //
  global define InstallPatches( list patch_list ) ``{
      string pre_info = "";
      string post_info = "";
      integer no = 1;
      integer package_count = 0;

      // remove old rpm logging
      SCR::Execute(.target.bash, "/bin/rm /var/log/y2logRPMShort" );
      SCR::Execute(.target.bash, "/bin/rm /var/log/y2logRPM" );      
      
      foreach ( `patch, patch_list, ``{
	  symbol ret = nil;
	  boolean go_on  = true;
	  
	  map check_version = SCR::Execute (.you.checkYaST2Version, version,patch );
 	  if ( lookup ( check_version, "ok", true ) )
	  {
	      // correct YaST2 version
	      list package_list = [];
	      list info_list = [];
	      list desc_list = [];
	      info_list = SCR::Read(.you.packages, patch );

	      foreach (`pac, info_list , ``{
		  package_list = add ( package_list, select ( pac, 0, "" ) );
		  desc_list = add ( desc_list, select( pac, 1, "" ) );
	      });
	      
	      y2debug("ONLINE: SCR::Read(.you.packages %1 ): %2 %3",
		      patch,
		      package_list,
		      desc_list);
	      if ( checkPackages ( package_list, patch ) )
	      {
		  // packages are ok
		  
		  pre_info = SCR::Read(.you.preInstallInformation,  patch);

		  if ( pre_info != "" &&
		       !auto_mode_install )
		  {
		      string header = sformat(_("Warning for patch %1"),
						    patch );
		      
		      go_on = UI::DisplayMsgYou( pre_info,
						 header,
						 _("&Install"),
						 _("&Skip patch"));

		      y2debug( "RREETTURRN: %1", go_on);
		  }
		  if ( go_on )
		  {
		      ret = CallFunction(`inst_rpmcopy(false, false,
						       package_list,
						       desc_list ));
		      y2debug("ONLINE: %1. call of inst_rpmcopy returns: %2",
			      no, ret );
		      package_count = package_count + size ( package_list );
		      no = no+1;
		      post_info = SCR::Read(.you.postInstallInformation,  patch);

		      if ( post_info != "" &&
			   !auto_mode_install )
		      {
			  string header = sformat(_("Information for patch %1"),
						  patch );

			  go_on = UI::DisplayMsgYouOk( post_info,
				header,
				_("&Ok"));
		      }
		  }

		  // do not set error status - let patch status NEW
      
		  if (ret == `abort )
		  {
		      // set status to error
		      SCR::Write(.you.patchUpdateStatus, patch, ERROR );
		      y2debug("ONLINE:  SCR::Write(.you.patchUpdateStatus,%1, %2)",
			      patch, ERROR );		      

		      OnlineUpdate::you_ok = false;
		      // ********************* foreach abbrechen **************
		      return `cancel;
		  }
		  else if ( ret == `next )
		  {
		      // set status to INSTALLED
		      SCR::Write(.you.patchUpdateStatus, patch, INSTALLED );
		      y2debug("ONLINE:  SCR::Write(.you.patchUpdateStatus,%1, %2)",
			      patch, INSTALLED );		      
		  }
	      }
	  }
	  else
	  {
	      // not the correct YaST2 Verison
	      string message = sformat(
		_("Patch %1 requires YaST2 version %2.
You have installed version %3.
"),
		patch,
		lookup ( check_version, "minYaST2Version", "-" ),
		version );
	      UI::DisplayMsgYouOk( message, _("Warning"), _("Don't install") );
	  }
      });

      OnlineUpdate::you_updated_packages = package_count;
      
      return `ok;
  };

  //  
  // Several functions of SCR(.you....) return a map of result information, e.g. 
  // $[ "ok": "true", "continue": false, "progress":"20", "message":"Download successful" ]
  // (not all information is used on every call)
  //  
  map result_map = $[];
  map new_patches = $[];
  boolean go_on = true;
  boolean success = true;

  if ( !continue_mode &&
       !auto_mode_install )
  {
      // The patch-list only has to loaded from you-server when module is called first time
      // and not only install local available patches.

      string connect_string = sformat( _("Starting download of patch descriptions from %1.\n"), you_server );
      UI::ChangeWidget(`id(`log), `LastLine, connect_string );

      if ( success )
      {
	  result_map = SCR::Execute(.you.connect, "");
	  y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result_map );	  

	  success = lookup( result_map, "ok", false );
	  string last_logging = lookup(result_map, "message", "" );
	  if ( size ( last_logging ) > 0 )
	  {
	      UI::ChangeWidget(`id(`log),
			       `LastLine, last_logging+"\n" );
	  }
      }

      if (success)
      {
	  // Remove all patches with status .new or .error, because we want to download
	  // the actual (possibly improved) descriptions from server
	  //  [ "Distribution_Version":"7.2","Product_Version":"3.0", "Product_Name":"Email Server" ] 
	 
	  map productInfo = SCR::Read (.you.productInfo);
	  y2debug("ONLINE: productInfo: %1", productInfo);	  
	  string patch_path = "";

	  if ( SCR::Read (.you.isBusiness) )
	  {
	      patch_path = sformat("/var/lib/YaST/patches/%1/update/%2/%3/patches/",
				   Arch::architecture,
				   lookup( productInfo, "Product_Name", "" ),
				   lookup( productInfo, "Product_Version", "" ));
	  }
	  else
	  {
	      patch_path = sformat("/var/lib/YaST/patches/%1/update/%2/patches/",
				   Arch::architecture,
				   lookup( productInfo, "Distribution_Version", "" ));
	  }
	  
	  string rm_files = patch_path + "*.new";
	  y2debug("ONLINE: patch file path %1", patch_path);
	  integer ret = SCR::Execute(.target.bash, sformat("rm -rf %1", rm_files ));
	  rm_files = patch_path + "*.error";
	  SCR::Execute(.target.bash, sformat("rm -rf %1", rm_files ));
	  
	  UI::ChangeWidget(`id(`status), `Value, _("active"));
	  while (go_on)
	  {
	      //get list of patches step by step
	      result_map = SCR::Execute(.you.getPatchList, ""); 
	      y2debug("ONLINE: SCR::Execute(.you.getPatchList) : %1", result_map );

	      go_on = lookup (result_map, "continue", false );

	      string message = lookup (result_map, "message", "" );
	      if ( message != "" )
	      {
		  UI::ChangeWidget(`id(`log), `LastLine, message +"\n" );
	      }
	      if ( lookup( result_map, "checkpatch" , "" ) != "" )
	      {
		  // checking gpg-key
		  string patchpath = lookup( result_map, "checkpatch" , "" );

		  string command = "/usr/bin/gpg -o " + patchpath
		      + ".unpack " + patchpath;
		  integer doresult = SCR::Execute (.target.bash, command );

		  if (doresult==0)
		  {
		      // check has been ok
		      SCR::Execute (.target.bash, "/bin/cp "
				    + patchpath
				    + ".unpack "
				    + patchpath );	  		  
		  }
		  else
		  {
		      string gpg_warning = sformat(
					    _("Cannot check patch %1 because the GPG package is not installed
or the patchdescription is corrupted.
SuSE cannot guarantee that the patch has been created by SuSE.
"),
					    message);		      
		      // not ok
		      boolean ret = UI::DisplayMsgYou( gpg_warning, _("Warning"),
					       _("&Install"), _("&Don't install") );
		      if ( ret )
		      {
			  // Does not matter
			  SCR::Execute (.target.bash, "/bin/cp "
					+ patchpath
					+ ".unpack "
					+ patchpath );	  		  

			  y2warning ( "installing anyway" );
		      }
		      else
		      {
			  // removing patch
			  SCR::Execute (.target.bash, "/bin/rm "
					+ patchpath );
			  
		      }
		  }
		  SCR::Execute (.target.bash, "/bin/rm "
				+patchpath
				+ ".unpack"   );	  		  
	      }

	      ShowProgress( lookup (result_map, "progress", 0 ) );
	  }
	  
	  success = lookup( result_map, "ok", false );
      }
      else
      {
	  
	  UI::ChangeWidget(`id(`log), `LastLine,
			   lookup (result_map, "message", "" ) ); 

	  if ( !auto_mode_get )
	  {
	      // Error popup if youConnect failed -
	      // Patch CD udpate: no CD in drive, mount failed
	      // Online Update: connecting to you server failed
	  
	      if ( cd_update )
	      {
		  UI::MessagePopup(_("Cannot access the patch descriptions.
Insert the SuSE patch CD and
restart the \"Patch CD Update\".
"));
		  return `abort;
	      }
	      else
	      {
		  UI::MessagePopup(_("Connection to YOU server failed.
Try to connect to another SuSE FTP/HTTP server.
"));
		  return `back;  
	      }
	  }
	  else
	  {
	      SCR::Execute(.you.closeUpdate, false); 
	      return `abort;	      
	  }
      }

      // disconnect
      map disconnect_map = SCR::Execute( .you.disconnect, "");
      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );
  
      if ( lookup(disconnect_map, "ok", false ) )
      {
	  UI::ChangeWidget(`id(`status), `Value, _("closed"));
      }

      string disconnect_message = lookup (disconnect_map, "message", "" );
      if ( size ( disconnect_message ) > 0 )
      {
	  UI::ChangeWidget(`id(`log), `LastLine, disconnect_message +"\n" );
      }

      ShowProgress( 0 );      
  }
  
  if (success)
  {
      new_patches = SCR::Read(.you.newPatchList);
      y2debug( "ONLINE: Reading patch data: %1", new_patches );
  }
  else
  {
      // Error popup if youGetPatchList failed -
      // Patch CD update: wrong CD in drive (path must be: <architecture>/update/<version>
      // Online Update: path on you server not found

      if ( !auto_mode_get &&
	   !auto_mode_install )
      {
	  if ( cd_update )
	  {
	      UI::MessagePopup(_("Cannot get the patches from CD.
Insert the SuSE patch CD
(check the version)
or update your system with YaST2
\"Online Update\".
")); 
	      return `abort;
	  }
	  else
	  {
	      UI::MessagePopup(_("Cannot get the patches from the server.
Try another SuSE FTP/HTTP server.
"));   
	      return `back;
	  }
      }
  }

  if ( !continue_mode &&
       !auto_mode_get &&
       !auto_mode_install )
  {
      // Evaluate, if there are YaST2 packages which have to be
      // updated first

      boolean yast2found = false;
      boolean notyast2found = false;
      map yast2map = $[];
      foreach( `patch, `patch_info, new_patches, ``{
	  if (  select ( patch_info, 3, "" ) == "X" &&
		select ( patch_info, 0, "" ) == "YaST2" )
	  {
	      yast2found = true;
	      yast2map = add ( yast2map, patch, patch_info );
	  }
	  else
	  {
	      if ( select ( patch_info, 3, "" ) == "X" )
	      {
		  notyast2found = true;
	      }
	      list dummy = [];
	      dummy = add ( dummy, select ( patch_info, 0, "" ) );
	      dummy = add ( dummy, select ( patch_info, 1, "" ) );
	      dummy = add ( dummy, select ( patch_info, 2, "" ) );
	      dummy = add ( dummy, " " );
	      yast2map = add ( yast2map, patch, dummy );
	  }
      });

      if ( yast2found && notyast2found )
      {
	  new_patches = yast2map;
	  y2milestone( " YaST2 patches found; only install %1",
		       new_patches );
	  // Message popup text: YaST2 patches found which should be installed first
	  UI::MessagePopup(_("There are YaST2 patches available.
These patches should be installed first.
Install these patches then run the YaST2 Online Update
again to install the rest of the packages.
"));
      }
  }
  
  if ( auto_mode )
  {
      if ( !auto_mode_get &&
	   !auto_mode_install )
      {
	  // calculate required download size
	  integer disk_size = 0;
	  foreach( `patch, `patch_info, new_patches, ``{
	      disk_size = disk_size + tointeger(
						select ( lookup(new_patches, patch, []), 2, "" ) )*1024;
	  });

	  if ( disk_size > 1000000 )
	  {
	      // only greater than 1 MB
	      string message = sformat (
		_("There are %1 patches on FTP/HTTP. Downloading may take a while.
Download the patches now?
"),
		size_text( disk_size ) );

	      if ( !UI::AnyQuestionPopup( "", message ,YesButtonLabel(), NoButtonLabel(), `yes_default) )
	      {
		  return `abort;		// abort update	      
	      }
	  }
      }

      list install_patches = [];
      
      if ( auto_mode_install )
      {
	  string batchkind = OnlineUpdate::you_auto_batchkind;
	  
	  // only use patches which already have been loaded from server
	  foreach( `patch, `patch_info, new_patches, ``{
	      // only get the patch if marked with "X" or "G" 
	      if ( select ( lookup(new_patches, patch, []), 3, "" ) == "X" ||
		   select ( lookup(new_patches, patch, []), 3, "" ) == "G")
	      {
		  if ( batchkind == "all" ||
		       batchkind == select ( lookup(new_patches, patch, []), 0, "" ) )
		  {
		      install_patches = add(install_patches, patch);
		  }
	      }
	  });	  
      }
      else
      {
	  // get the patches
	  install_patches = GetAllPatches( new_patches );
      }

      if ( !auto_mode_get )
      {
	  if ( size (install_patches) >0 )
	  {
	      y2debug( "ONLINE: automatic mode, installing: %1", install_patches );

	      // go on and install all available patches in auto_mode
	      any ret = InstallPatches( install_patches );
	      return `next;
	  }
	  else
	  {
	      if ( !auto_mode_install )
	      {
		  any ret = SCR::Execute( .you.disconnect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", ret );

		  UI::MessagePopup(_("No patch to install."));
	      }
	      return `abort;		// abort update
	  }
      }
      else
      {
	  // Patches has been get only; Finish you update
	  y2debug("ONLINE: close update with status: %1", OnlineUpdate::you_ok );
	  SCR::Execute(.you.closeUpdate, OnlineUpdate::you_ok); 	  
	  return `abort;
      }
  }
  else if ( !continue_mode )
  {
      // store map with new patches -> table input online_update_select
      OnlineUpdate::you_patches = new_patches;
      y2debug( "Wrote list of new patches: %1", new_patches );

      // prepare for second call in manual mode 
      OnlineUpdate::you_continue = true;

      // got patches -> go `next if CD update
      if ( cd_update )
	  return `next;
  }
  else if ( continue_mode )
  {
      // get selected patches (written from online_update_select)
      map get_patches = OnlineUpdate::you_patches;

      list install_patches = GetAllPatches( get_patches );

      if ( size ( install_patches ) > 0 )
      {
	  y2debug( "ONLINE: manual mode, installing: %1", install_patches );

	  while (true)
	  {
	      any r = UI::UserInput();
	      if ( r == `next )
	      {
		  // install selected patches
		  any ret = InstallPatches( install_patches );
		  return `next;
	      }
	      else if ( r == `abort  && UI::ConfirmAbortUpdate(`incomplete) )
	      {
		  // set CloseUpdate status to false (installation NOT complete)
		  SCR::Execute(.you.closeUpdate, false);
		  map disconnect_map = SCR::Execute(.you.disconnect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  
		  return `abort;	// abort update
	      }
	  }
      }
      else
      {
	  // do not set the CloseUpdate status -> no patch is installed
	  map disconnect_map = SCR::Execute(.you.disconnect, "");
	  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  	  
	  UI::MessagePopup(_("No patch will be installed."));

	  return `finish;
	  //return `abort;
      }
  }
  else
  {
      map disconnect_map = SCR::Execute(.you.disconnect, "");
      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  	  
      
      y2error("online_update_load - mode not set");
      return `abort;
  }
	 
	 
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////  Loop for User Input ....
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////
  symbol ret = `next;

  repeat
      {
	  ret= UI::UserInput();

	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  ////  FINISH
	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if ( ret == `abort && UI::ConfirmAbortUpdate(`incomplete) )
	  {
	      map disconnect_map = SCR::Execute(.you.disconnect, "");
	      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  	  

	      return `abort;
	  }

	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  ////  
	  ////////////////////////////////////////////////////////////////////////////////////////////////////////

	  if ( ret == `back)
	  {
	      // RESET continue mode
	      OnlineUpdate::you_continue = false;
	  }

      } until (ret == `next || ret == `back || ret == `cancel);

  y2debug("online_update_load Return: %1", ret );
  return ret;
}



