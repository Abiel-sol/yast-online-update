/*
 *************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Gabriele Strattner <gs@suse.de>
 *
 * Purpose:
 *
 * Modify:
 *
 * external function:
 *
 *
 *************************************************************
 $Id$
*/

{
  textdomain "online_update";
  
  // Testmode
  boolean test_mode    = lookup ( user_settings, "test_mode", false );
  
  // selected ftp server
  string ftp_server = lookup( user_settings, "ftp_server", "" );
  string ftp_dir = lookup( user_settings, "ftp_dir", "" );
  
  // check installation mode
  boolean auto_mode 	= lookup( user_settings, "ftp_auto", false );
  boolean continue_mode = lookup( user_settings, "ftp_continue", false );

  boolean cd_update 	= lookup( user_settings, "cd_update", false );
  
  // prepare for inst_rpmcopy
  user_settings = add(user_settings, "post_install", true );
  map installMap = $[];
  installMap 	= add(installMap, "bootmode", "Harddisk" );
  user_settings = add(user_settings, "installMap", installMap );

  // possible status information
  string ERROR = "error";
  string INSTALLED = "installed";
  string LOAD = "load";
  
  user_settings = add(user_settings, "ftp_ok", true );
  
  //////////////////////////////////////////////////////////////////////////////
  //                                  P O P U P S                             //
  //////////////////////////////////////////////////////////////////////////////

  global define ShowProgress( integer percent )``{
      
      y2debug("PROGRESS: %1", percent );
      UI(`ChangeWidget(`id(`progress), `Value, percent ));
  };

  
  ///////////////////////////////////////////////////////////////////////////////
  // MAIN:
  ///////////////////////////////////////////////////////////////////////////////

  term download = nil;
  
  if ( UI(`HasSpecialWidget(`DownloadProgress ) ))
  {
      download = `Left(`DownloadProgress(`id(`fileProgress),_("Current patch"), "", 0 ));
  }
  else
  {
      download = `Empty();
  }

  term contents =
      // main dialog: 
      `VBox(
	    `VSpacing( 0.2 ),
	    `HBox(
		  `HWeight( 50,`VBox(`Left(`Label(_("Connected to"))),
				     `Left(`Label(`id(`id1),`opt(`outputField), "                                          "))
				      )
			    ),
		  `HWeight( 50,`VBox(`Left(`Label(_("Status of connection"))),
				     `Left(`Label(`id(`status),`opt(`outputField), "                                          "))
				      )
			    )
		  ),
	    `VSpacing(0.5),
	    download,
	    `Left(`ProgressBar(`id(`progress), _("Total progress"), 100)),
	    `LogView(`id(`log),
		     _("Information about the activities"),
		     5,		// visible lines
		     500),	// lines to store,
	    `VSpacing( 0.2 )
	    );

  string help_text = "";

  // helptext  "Connection and Data transfer" 
  string help_part11 =  UI(_("<p>After connecting to SuSE server,
YaST2 will download all selected patches.
This could take some time. Several details are shown.</p>"));

  string help_part12 = UI(_("<p>The patches will be copied
to the harddisk.<br>
Informations about the ftp connection are not relevant
for CD installation.</p>"));
  
  string help_part2 =  UI(_("<p>
The fields above show information about the connection and
time of data transfer.
The box below displays data from ftp logfile. If something
goes wrong, please check this source of information. 
</p>"));
  string help_part3 =  UI(_("<p>
If you decide to <b>Abort Update</b>, the download of
patches will be interrupted. No patch will be installed.
The ftp connection will be closed. 
</p>"));

  if ( !cd_update )
  {
      help_text = help_part11 + help_part2 + help_part3;
  }
  else
  {
      help_text = help_part12 + help_part2 + help_part3;
  }

  if ( !cd_update || continue_mode )
  {
      UI(`SetWizardContents(_("Connection and Data transfer"), contents, help_text, Args(0), Args(1) ));

      UI(`ChangeWidget(`id(`id1), `Value, ftp_server) );  
      UI(`ChangeWidget(`id(`status), `Value, _("closed") ));
  }

  // Fake getting of patches for fake_mode (NOT USED)
  integer test_id = 0;
  global define FakeGetPatch( string patch) ``{
      integer counter = 0;
      string log = "";
      map result = $[];
      
      while (counter < 100)
      {
	  counter = counter + 1;
	  UI(`ChangeWidget(`id(`log), `LastLine, "Neue Zeile ........\n" ));
      }
      test_id = test_id + 1;
	 
      y2debug("ONLINE: Get patch %1 ( fake_mode ): %2", patch, test_id != 3 );

      if (test_id == 3)
      {
	  result = add(result, "ok", false );
	  string msg =  sformat( "Download failed for patch %1.\nReasons are unknown.", patch );
	  result = add( result, "message", msg );
      }
      else
      {
	  result = add(result, "ok", true );
	  string msg = sformat("Download successful for patch %1.\n", patch );
	  result = add( result, "message", msg );
      }
      result = add(result, "progress", test_id*10);
      result = add(result, "continue", false );
      
      return result;
  };

  // get patches from ftp server
  global define GetAllPatches( map new_patches ) ``{
      list ret_list = [];
      list patch_list = [];
      integer index = 0;
      boolean go_on = true;
      integer patch_no = 0;
      
      foreach( `patch, `patch_info, new_patches, ``{
	  // only get the patch if marked with "X" or "G" 
	  if ( select ( lookup(new_patches, patch, []), 3 ) == "X" || select ( lookup(new_patches, patch, []), 3 ) == "G")
	   {
	       patch_list = add(patch_list, patch);
	   }
      });
      patch_no = size(patch_list);

      if ( patch_no == 0 )
      {
	  // nothing will do
	  return ret_list;
      }

      string connect_string = sformat ( UI(_("Starting download of selected patches from %1.\n")), ftp_server );
      UI(`ChangeWidget(`id(`log), `LastLine, connect_string ));

      map  result_map = PKGINFO(`ftpConnect());
      y2debug("ONLINE:  PKGINFO(`ftpConnect()): %1", result_map );
      connect_string = lookup (result_map, "message", "" );
      if ( size ( connect_string ) > 0 )
      {
	  UI(`ChangeWidget(`id(`log), `LastLine, connect_string+"\n" ));
      }
      if (lookup( result_map, "ok", false )  )
      {
	  UI(`ChangeWidget(`id(`status), `Value, _("active")) );
      }

      ShowProgress( 5 );

      string lastErrorServer = ftp_server; // only for error popup      
      
      while ( (index < patch_no) && go_on )
      {
	  map patch_result = $[];
	  string patch = select(patch_list, index);
	  
	  y2debug("Status of patch %1: %2", patch, select( lookup(new_patches, patch, []), 3 ));

	  UI(`ChangeWidget(`id(`log), `LastLine, sformat( UI(_("Get packages for patch %1\n")), patch) ) );
	  
	  patch_result = PKGINFO( `ftpGetPatch( select(patch_list, index) ) );
	  y2debug("ONLINE: PKGINFO(ftpGetPatch( %1 )): %2", select(patch_list, index), patch_result );
	  while ( lookup(patch_result, "ok", false) == true &&
		  lookup(patch_result, "nextPackage","") != "" )
	  {
	      boolean otherServerConnect = false;
	      
	      y2debug("ONLINE: PKGINFO(ftpGetPatch( %1 )): %2", select(patch_list, index), patch_result );
	      UI(`ChangeWidget(`id(`log), `LastLine, "Package " +
			    lookup(patch_result, "nextPackage","") +
			   "\n" ));
	      UI(`ChangeWidget(`id(`fileProgress), `ExpectedSize, lookup(patch_result, "nextPackageSize",0)) );
	      UI(`ChangeWidget(`id(`fileProgress), `Filename, lookup(patch_result, "nextPackage","")) );

	      string otherFtpServer = lookup ( patch_result, "nextFtpServer", "" );
	      
	      // Checking, if the package is on another server; not when the
	      // source is CD, Harddisk....
	      if ( ftp_server != "local" &&
		   ftp_server != "Net" &&
		   ftp_server != "CD" &&
		   ftp_server != "Harddisk" &&
		   size ( otherFtpServer ) > 0 )
	      {
		  map result = $[];

		  otherServerConnect = true;
		  
		  // disconnect from the old server
		  result = PKGINFO(`ftpDisconnect());
		  y2debug("ONLINE:  PKGINFO(`ftpDisonnect()): %1", result );
		  string last_logging = lookup(result, "message", "" );
		  if ( size ( last_logging ) > 0 )
		  {
		      UI(`ChangeWidget(`id(`log), `LastLine, last_logging+"\n" ));
		  }
		  if ( lookup( result, "ok", false )  )
		  {
		      UI(`ChangeWidget(`id(`status), `Value, _("closed")) );
		  }
		  
		  // connecting to other ftp-server

		  any retval = PKGINFO(`ftpSetServer( otherFtpServer,"." ) );
		  y2debug("ONLINE: PKGINFO(`setFtpServer( %1, %2 ) ): %3",
			  otherFtpServer, ".", retval );
		
		  if (retval == nil || retval == false)
		  {
		      last_logging = sformat ( UI(_("Connection failed to %1\n")), otherFtpServer );
		      UI(`ChangeWidget(`id(`log), `LastLine, last_logging ));		      
		  }
		  else
		  {
		      // connect to new server
		      result = PKGINFO(`ftpConnect());
		      y2debug("ONLINE:  PKGINFO(`ftpConnect()): %1", result );
		      string connect_string = lookup (result, "message", "" );
		      if ( size ( connect_string ) > 0 )
		      {
			  UI(`ChangeWidget(`id(`log), `LastLine, connect_string+"\n" ));
		      }
		      if (lookup( result, "ok", false )  )
		      {
			  UI(`ChangeWidget(`id(`status), `Value, _("active")) );
			  UI(`ChangeWidget(`id(`id1), `Value, otherFtpServer) );  			  
		      }
		  }
	      }

	      // Getting rpm
	      patch_result = PKGINFO( `ftpGetPatch( select(patch_list, index) ) );
	      if ( !lookup(patch_result, "ok", false)  )
	      {
		  if ( otherServerConnect )
		  {
		      lastErrorServer = otherFtpServer;
		  }
		  else
		  {
		      lastErrorServer = ftp_server;
		  }
	      }

	      
	      if ( otherServerConnect )
	      {
		  //Reconnect to old server
		  map result = $[];

		  otherServerConnect = false;
		  
		  // disconnect from  server
		  result = PKGINFO(`ftpDisconnect());
		  y2debug("ONLINE:  PKGINFO(`ftpDisonnect()): %1", result );
		  string last_logging = lookup(result, "message", "" );
		  if ( size ( last_logging ) > 0 )
		  {
		      UI(`ChangeWidget(`id(`log), `LastLine, last_logging+"\n" ));
		  }
		  if ( lookup( result, "ok", false )  )
		  {
		      UI(`ChangeWidget(`id(`status), `Value, _("closed")) );
		  }
		  
		  // setting to old ftp-server
		  any retval = PKGINFO(`ftpSetServer( ftp_server,
					 ftp_dir ) );
		  y2debug("ONLINE: PKGINFO(`setFtpServer( %1, %2 ) ): %3",
			  ftp_server, ftp_dir, retval );
		
		  if (retval == nil || retval == false)
		  {
		      last_logging = sformat ( UI(_("Connection failed to %1\n")), ftp_server );
		      UI(`ChangeWidget(`id(`log), `LastLine, last_logging ));		      
		  }

		  // connect to old server
		  result = PKGINFO(`ftpConnect());
		  y2debug("ONLINE:  PKGINFO(`ftpConnect()): %1", result );
		  if (lookup( result, "ok", false )  )
		  {
		      UI(`ChangeWidget(`id(`status), `Value, _("active")) );
		      UI(`ChangeWidget(`id(`id1), `Value, ftp_server) );  		      
		  }
	      }
	  }
	  
	  if ( !lookup(patch_result, "ok", false) )
	  {
	      // set status to error
	      PKGINFO( `ftpChangePatchUpdateStatus( select(patch_list, index), ERROR ) );
	      y2debug("ONLINE:  PKGINFO( `ftpChangePatchUpdateStatus(%1, %2)", select(patch_list, index), ERROR );
	      user_settings = add(user_settings, "ftp_ok", false );
	       
	      // put logging into LogView Widget before showing popup
	      string last_logging = lookup(patch_result, "message", "" );
	      if ( size ( last_logging ) > 0 )
	      {
		  UI(`ChangeWidget(`id(`log), `LastLine, last_logging+"\n" ));
	      }
	      
	      string msg_str = sformat(UI(_("Can't get patch \"%1\" from
server \"%2\".
You may try to download remaining patches or
go on with installing of already got ones.")),
				       select(patch_list, index), lastErrorServer );
	      
	      any ret = UI(`DisplayMsgFtp( msg_str, _("Notify"), _("&Download"), _("&Install") ));

	      if (!ret)
	      {
		  go_on = false;
	      }
	  }
	  else if ( select ( lookup(new_patches, patch, []), 3 ) == "X" )
	  {
	      // patches marked with "X" will be installed
	      ret_list = add( ret_list, select(patch_list, index) );
	      // put logging into LogView Widget
	  }

	  string log_string = lookup(patch_result, "message", "" );
	  if ( log_string != "" )
	  {
	      UI(`ChangeWidget(`id(`log), `LastLine, log_string+"\n" ));
	  }

	  // Polling input to give the user a chance to stop the download  
	  any r = UI(`PollInput());
	  if ( r == `abort && UI(`DisplayMsgFtp( _("Download of patches will be stopped.
You may continue with installation of already
loaded patches or abort update completely."), _("Warning"), _("&Install"), _("&Abort") )) )
	  {
	      go_on = false;
	  }
	  
	  index = index+1;
	  if (((index*100)/patch_no) > 95 )
	  {
	      ShowProgress( 95 );	      
	  }
	  else
	  {
	      ShowProgress( (index*100)/patch_no );
	  }
      }
      
      ShowProgress( 0 );

      UI(`ChangeWidget(`id(`fileProgress), `Filename, "") );      
      UI(`ChangeWidget(`id(`fileProgress), `ExpectedSize, 1024) );
      
      // disconnect
      map result = PKGINFO(`ftpDisconnect());
      y2debug("ONLINE:  PKGINFO(`ftpDisonnect()): %1", result );
      string last_logging = lookup(result, "message", "" );
      if ( size ( last_logging ) > 0 )
      {
	  UI(`ChangeWidget(`id(`log), `LastLine, last_logging+"\n" ));
      }
      if (lookup( result, "ok", false )  )
      {
	  UI(`ChangeWidget(`id(`status), `Value, _("closed")) );
      }
      
      return ret_list;
  };

  //
  // Checking packages for consistents and original SuSE-packages
  //
  global define checkPackages( list package_list, string patch ) ``{
      boolean install = true;
      boolean dontAsk = false;

      string tmpfile = SCR(`Read(.run.mktemp));

      string pgp_warning = sformat(
				   UI(_("Cannot check the patch %1 cause the PGP key is not installed or is corrupted.\nSo SuSE cannot guarantee that the packages has been created by SuSE")),
			       patch);
      
      y2milestone ( "tmpfile : %1", tmpfile );
      foreach ( `package, package_list, ``{
	  integer ret_shell = SCR(`Execute(.target.bash,
				"/bin/rpm --checksig " + package + " >" + tmpfile + " 2>>" + tmpfile ));
	  if ( ret_shell != 0 )
	  {
	      if ( SCR (`Execute (.target.bash, "/bin/grep -i \"GPG NOT OK\" " + tmpfile )) == 0 )
	      {
		  boolean ret = true;

		  y2warning ( "package %1 returned pgp-error",
				package );
		  if ( !dontAsk )
		  {
		      ret = UI(`DisplayMsgFtp( pgp_warning, _("Warning"),
					       _("&Install"), _("&Don't install") ));
		      if ( !ret )
		      {
			  install = false;
			  y2warning ( "installing anyway" );
		      }
		      dontAsk = true;
		  }
	      }
	      else
	      {
		  string message = sformat(
					   UI(_("The patch %1 will not be installed \ncause package %2 is corrupted")),
					   patch, package );
	      
		  y2error( "%1", message );
	      
		  UI(`DisplayMsgFtpOk( message, _("Error"), _("&ok") ));
		  install = false;
	      }
	  }
	  else
	  {
	      // Checking, if gpg was available
	      if ( SCR (`Execute (.target.bash, "/bin/grep -i \"GPG\" " + tmpfile )) != 0 )
	      {
		  y2warning ( "package %1 no pgp-key found",
				package );
		  
		  if ( !dontAsk )
		  {
		      boolean ret = true;
		      
		      ret = UI(`DisplayMsgFtp( pgp_warning, _("Warning"),
					       _("&Install"), _("&Don't install") ));
		      if ( !ret )
		      {
			  install = false;
			  y2warning ( "installing anyway" );
		      }
		      dontAsk = true;
		  }
	      }
	  }
	  
	  SCR (`Execute (.target.bash, "/bin/rm " + tmpfile ));	  
      });
      
      return install;
  };

    
  //
  // InstallPatches
  // call inst_rpmcopy for every patch with list of packages belonging to the patch
  //
  global define InstallPatches( list patch_list ) ``{
      string pre_info = "";
      string post_info = "";
      integer no = 1;
      integer package_count = 0;

      // remove old rpm logging
      SCR(`Execute(.target.bash, "/bin/rm /var/log/y2logRPMShort" ));
      SCR(`Execute(.target.bash, "/bin/rm /var/log/y2logRPM" ));      
      
      foreach ( `patch, patch_list, ``{
	  symbol ret = nil;
	  boolean go_on  = true;

	  map check_version = PKGINFO(`ftpCheckYaST2Version(version,patch));
	  if ( lookup ( check_version, "ok", true ) )
	  {
	      // correct YaST2 version
	      list package_list = [];
	      list info_list = [];
	      list desc_list = [];
	      info_list = PKGINFO( `ftpGetPackages( patch ));

	      foreach (`pac, info_list , ``{
		  package_list = add ( package_list, select ( pac, 0 ) );
		  desc_list = add ( desc_list, select( pac, 1) );
	      });
	      
	      y2debug("ONLINE: PKGINFO(`ftpGetPackages( %1 )): %2 %3",
		      patch,
		      package_list,
		      desc_list);
	      if ( checkPackages ( package_list, patch ) )
	      {
		  // packages are ok
		  
		  pre_info = PKGINFO(`ftpGetPreInstallInformation(patch));

		  if ( pre_info != "" )
		  {
		      string header = sformat(UI(_("Warning for patch %1")),
						    patch );
		      
		      go_on = UI(`DisplayMsgFtp( pre_info,
						 header,
						 _("&Install"),
						 _("&Skip patch")));

		      y2debug( "RREETTURRN: %1", go_on);
		  }
		  if ( go_on )
		  {
		      ret = CallFunction(`inst_rpmcopy(false, false,
						       package_list,
						       desc_list ));
		      y2debug("ONLINE: %1. call of inst_rpmcopy returns: %2",
			      no, ret );
		      package_count = package_count + size ( package_list );
		      no = no+1;
		      post_info = PKGINFO(`ftpGetPostInstallInformation(
								patch));

		      if ( post_info != "" )
		      {
			  string header = sformat(UI(_("Information for patch %1")),
						  patch );

			  go_on = UI(`DisplayMsgFtpOk( post_info,
				header,
				_("&Ok")));
		      }
		  }

		  // do not set error status - let patch status NEW
      
		  if (ret == `abort )
		  {
		      // set status to error
		      PKGINFO( `ftpChangePatchUpdateStatus( patch, ERROR ) );
		      y2debug(
		      "ONLINE:  PKGINFO( `ftpChangePatchUpdateStatus(%1, %2)",
		      patch, ERROR );
		      user_settings = add(user_settings, "ftp_ok", false );
		      // ********************* foreach abbrechen **************
		      return `cancel;
		  }
		  else if ( ret == `next )
		  {
		      // set status to INSTALLED
		      PKGINFO( `ftpChangePatchUpdateStatus( patch,
							    INSTALLED ) );
		      y2debug(
  		      "ONLINE:  PKGINFO( `ftpChangePatchUpdateStatus(%1, %2)",
		      patch, INSTALLED );
		  }
	      }
	  }
	  else
	  {
	      // not the correct YaST2 Verison
	      string message = sformat(
		UI(_("The patch %1 needs the version %2 of YaST2.\nYou have installed version %3")),
		patch,
		lookup ( check_version, "minYaST2Version", "-" ),
		version );
	      UI(`DisplayMsgFtpOk( message, _("Warning"), _("Don't install") ));
	  }
      });

      user_settings = add ( user_settings, "ftp_updated_packages",
			    package_count );
      
      return `ok;
  };

  //  
  // Several functions of PKGINFO return a map of result information, e.g. 
  // $[ "ok": "true", "continue": false, "progress":"20", "message":"Download successful" ]
  // (not all information is used on every call)
  //  
  map result_map = $[];
  map new_patches = $[];
  boolean go_on = true;
  boolean success = true;

  if ( !continue_mode )
  {
      // The patch-list only has to loaded from ftp-server when module is called first time 

      string connect_string = sformat( UI(_("Starting download of patch descriptions from %1.\n")), ftp_server );
      UI(`ChangeWidget(`id(`log), `LastLine, connect_string ));

      if ( success )
      {
	  result_map = PKGINFO(`ftpConnect());
	  success = lookup( result_map, "ok", false );
	  y2debug("ONLINE:  PKGINFO(`ftpConnect()): %1", result_map );
	  string last_logging = lookup(result_map, "message", "" );
	  if ( size ( last_logging ) > 0 )
	  {
	      UI(`ChangeWidget(`id(`log),
			       `LastLine, last_logging+"\n" ));
	  }
      }

      if (success)
      {
	  // Remove all patches with status .new or .error, because we want to download
	  // the actual (possibly improved) descriptions from server
	 
	  // $[ "installedVersion":"SuSE 6.3", "updateVersion":"SuSE 6.4" ]
	  map versions = PKGINFO(`readVersions());
	  string version = lookup( versions, "installedVersion", "" );
	  string patch_path = sformat("/var/lib/YaST/patches/%1/update/%2/patches/",
				      lookup(user_settings, "architecture", "i386"),
      				      substring( version, size(version)-7, 3 ) );
	  
	  string rm_files = patch_path + "*.new";
	  y2debug("ONLINE: patch file path %1", patch_path);
	  integer ret = SCR(`Execute(.target.bash, sformat("rm -rf %1", rm_files )));
	  rm_files = patch_path + "*.error";
	  SCR(`Execute(.target.bash, sformat("rm -rf %1", rm_files )));
	  
	  UI(`ChangeWidget(`id(`status), `Value, _("active")) );
	  while (go_on)
	  {
	      //get list of patches step by step
	      result_map = PKGINFO(`ftpGetPatchList( ));
	      y2debug("ONLINE:  PKGINFO(`ftpGetPatchList()): %1", result_map );

	      go_on = lookup (result_map, "continue", false );

	      string message = lookup (result_map, "message", "" );
	      if ( message != "" )
	      {
		  UI(`ChangeWidget(`id(`log), `LastLine, message +"\n" ));
	      }

	      ShowProgress( lookup (result_map, "progress", 0 ) );
	  }
	  
	  success = lookup( result_map, "ok", false );
      }
      else
      {
	  UI(`ChangeWidget(`id(`log), `LastLine,
			   lookup (result_map, "message", "" ) )); 
	  if ( lookup( user_settings, "ftp_server", "" ) == "CD" )
	  {
	      UI(`MessagePopup(_("Can't get patch descriptions.
Please insert SuSE patch CD.")));
	      return `abort;
	  }
	  else
	  {
	      UI(`MessagePopup(_("Connection to ftp server failed.
Please try to get connection to another SuSE ftp server.")));
	      return `back;  
	  }
      }

      // disconnect 
      map disconnect_map = PKGINFO(`ftpDisconnect());

      y2debug( "ONLINE:  PKGINFO(`ftpDisconnect(): %1",  disconnect_map );
  
      if ( lookup(disconnect_map, "ok", false ) )
      {
	  UI(`ChangeWidget(`id(`status), `Value, _("closed")) );
      }

      string disconnect_message = lookup (disconnect_map, "message", "" );
      if ( size ( disconnect_message ) > 0 )
      {
	  UI(`ChangeWidget(`id(`log), `LastLine, disconnect_message +"\n" ));
      }

      ShowProgress( 0 );      
  }
  
  if (success)
  {
      new_patches = PKGINFO(`ftpNewPatchList( ));
      y2debug( "ONLINE: Reading patch data: %1", new_patches );
  }
  else
  {
      if ( cd_update )
      {
	  // set cd_update false before going back - user must select CD installation first 
	  user_settings = add (user_settings, "cd_update", false );
	  user_settings = add (user_settings, "ftp_server", "ftp.suse.com" );
	  
	  UI(`MessagePopup(_("YaST2 can't get the patches
because a different source media was
used on previous installation.\n
Please select button \"Expert\" on start
page and select \"CD installation\" on
appearing dialog. Insert the patch CD
before proceeding.\n")));
      }
      else
      {
	  UI(`MessagePopup(_("Can't get patches from server.
Please try to get patches from another SuSE ftp server.")));   
      }
      return `back;
  }

  if ( !continue_mode )
  {
      // Evaluate, if there are YaST2 packages which have to be
      // updated first

      boolean yast2found = false;
      boolean notyast2found = false;
      map yast2map = $[];
      foreach( `patch, `patch_info, new_patches, ``{
	  if (  select ( patch_info, 3 ) == "X" &&
		select ( patch_info, 0 ) == "YaST2" )
	  {
	      yast2found = true;
	      yast2map = add ( yast2map, patch, patch_info );
	  }
	  else
	  {
	      if ( select ( patch_info, 3 ) == "X" )
	      {
		  notyast2found = true;
	      }
	      list dummy = [];
	      dummy = add ( dummy, select ( patch_info, 0 ) );
	      dummy = add ( dummy, select ( patch_info, 1 ) );
	      dummy = add ( dummy, select ( patch_info, 2 ) );
	      dummy = add ( dummy, " " );
	      yast2map = add ( yast2map, patch, dummy );
	  }
      });

      if ( yast2found && notyast2found )
      {
	  new_patches = yast2map;
	  y2milestone( " YaST2 patches found; only install %1",
		       new_patches );
	  UI(`MessagePopup(_("There are YaST2 patches available.
These patches should be installed first.
Please install these patches and call YaST2 online update once
again to install the rest of the packages.")));
      }
  }
  
  if ( auto_mode )
  {
      // calculate required download size
      integer disk_size = 0;
      foreach( `patch, `patch_info, new_patches, ``{
	  disk_size = disk_size + tointeger(
		    select ( lookup(new_patches, patch, []), 2 ) )*1024;
      });

      if ( disk_size > 1000000 )
      {
	  // only greater than 1 MB
	  string message = sformat (
	       UI(_("There are %1 patches on ftp. Downloading may take a while.\n Do you really want to download the patches now?")),
 	       my_size_text( disk_size ) );

	  if ( !UI(`DisplayAnyQuestion( `none, message ,_("&Yes"), _("&No"), `yes_default)) )
	  {
	      return `abort;		// abort update	      
	  }
      }

      
      // get the patches
      list install_patches = GetAllPatches( new_patches );

      if ( size (install_patches) >0 )
      {
	  y2debug( "ONLINE: automatic mode, installing: %1", install_patches );

	 // go on and install all available patches in auto_mode
	 any ret = InstallPatches( install_patches );
	 return `next;
      }
      else
      {
	  any ret = PKGINFO(`ftpDisconnect());
	  y2debug("ONLINE:  PKGINFO(`ftpDisconnect()): %1", ret );
	  UI(`MessagePopup(_("There is no patch which will have to be installed.")));	  
	  return `abort;		// abort update
      }
  }
  else if ( !continue_mode )
  {
      // write new_patches to user_settings -> table input online_update_select
      user_settings = add(user_settings, "ftp_patches", new_patches );
      y2debug( "Wrote list of new patches to user_settings: %1", new_patches );

      // prepare for second call in manual mode 
      user_settings = add(user_settings, "ftp_continue", true );

      // got patches and write new_patches to user_settings -> go `next if CD update
      if ( cd_update )
	  return `next;
  }
  else if ( continue_mode )
  {
      // get selected patches (written to user_settings from online_update_select)
      map get_patches = lookup( user_settings, "ftp_patches", $[] );

      list install_patches = GetAllPatches( get_patches );

      if ( size ( install_patches ) > 0 )
      {
	  y2debug( "ONLINE: manual mode, installing: %1", install_patches );

	  while (true)
	  {
	      any r = UI(`UserInput());
	      if ( r == `next )
	      {
		  // install selected patches
		  any ret = InstallPatches( install_patches );
		  return `next;
	      }
	      else if ( r == `abort  && UI(`ConfirmAbortUpdate(`incomplete)) )
	      {
		  // set CloseUpdate status to false (installation NOT complete)
		  PKGINFO(`ftpCloseUpdate(false) );
		  any ret = PKGINFO(`ftpDisconnect());
		  y2debug("ONLINE:  PKGINFO(`ftpDisconnect()): %1", ret );
		  return `abort;	// abort update
	      }
	  }
      }
      else
      {
	  // do not set the CloseUpdate status -> no patch is installed
	  PKGINFO(`ftpDisconnect());
	  y2debug("ONLINE:  PKGINFO(`ftpDisconnect())" );
	  UI(`MessagePopup(_("No patch will be installed.")));

	  return `finish;
	  //return `abort;
      }
  }
  else
  {
      PKGINFO(`ftpDisconnect());
      y2debug("ONLINE:  PKGINFO(`ftpDisconnect()): %1", ret );
      y2error("online_update_load - mode not set");
      return `abort;
  }
	 
	 
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////  Loop for User Input ....
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////
  symbol ret = `next;

  repeat
      {
	  ret= UI(`UserInput());

	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  ////  FINISH
	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if ( ret == `abort && UI(`ConfirmAbortUpdate(`incomplete)) )
	  {
	      PKGINFO(`ftpDisconnect());
	      y2debug("ONLINE:  PKGINFO(`ftpDisconnect()): %1", ret );
	      return `abort;
	  }
	  if (ret == `next)
	  {

	  }

	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  ////  
	  ////////////////////////////////////////////////////////////////////////////////////////////////////////

	  if ( ret == `back)
	  {
	      // RESET continue mode
	      user_settings = add(user_settings, "ftp_continue", false );
	  }

      } until (ret == `next || ret == `back || ret == `cancel);

  y2debug("online_update_load Return: %1", ret );
  return ret;
}



