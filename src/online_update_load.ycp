/*
 *************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Gabriele Strattner <gs@suse.de>
 *
 * Purpose:
 *
 * Modify:
 *
 * external function:
 *
 *
 *************************************************************
 $Id$
*/

{
  textdomain "online_update";
  
  // Testmode
  boolean test_mode    = lookup ( user_settings, "test_mode", false );

  boolean business    = lookup( user_settings, "business", false );  
  
  // selected you server
  string you_server = lookup( user_settings, "you_server", "" );
  string you_serverkind = lookup( user_settings, "you_serverkind", "" );  
  string you_dir = lookup( user_settings, "you_dir", "" );
  
  // check installation mode
  boolean auto_mode 	= lookup( user_settings, "you_auto", false );
  boolean continue_mode = lookup( user_settings, "you_continue", false );
  boolean auto_mode_get = lookup( user_settings, "you_auto_get", false );
  boolean auto_mode_install = lookup( user_settings, "you_auto_install",
				      false );
  boolean cd_update 	= lookup( user_settings, "cd_update", false );
  
  // prepare for inst_rpmcopy
  user_settings = add(user_settings, "post_install", true );
  map installMap = $[];
  installMap 	= add(installMap, "bootmode", "Harddisk" );
  user_settings = add(user_settings, "installMap", installMap );

  // possible status information
  string ERROR = "error";
  string INSTALLED = "installed";
  string LOAD = "load";
  
  user_settings = add(user_settings, "you_ok", true );
  
  //////////////////////////////////////////////////////////////////////////////
  //                                  P O P U P S                             //
  //////////////////////////////////////////////////////////////////////////////

  global define ShowProgress( integer percent )``{
      
      y2debug("PROGRESS: %1", percent );
      UI::ChangeWidget(`id(`progress), `Value, percent );
  };

  
  ///////////////////////////////////////////////////////////////////////////////
  // MAIN:
  ///////////////////////////////////////////////////////////////////////////////

  term download = nil;
  
  if ( UI::HasSpecialWidget(`DownloadProgress ) )
  {
      download = `Left(`DownloadProgress(`id(`fileProgress),_("Current patch"), "", 0 ));
  }
  else
  {
      download = `Empty();
  }

  term contents =
      // main dialog: 
      `VBox(
	    `VSpacing( 0.2 ),
	    `HBox(
		  `HWeight( 50,`VBox(`Left(`Label(_("Connected to"))),
				     `Left(`Label(`id(`id1),`opt(`outputField), "                                          "))
				      )
			    ),
		  `HWeight( 50,`VBox(`Left(`Label(_("Status of connection"))),
				     `Left(`Label(`id(`status),`opt(`outputField), "                                          "))
				      )
			    )
		  ),
	    `VSpacing(0.5),
	    download,
	    `Left(`ProgressBar(`id(`progress), _("Total progress"), 100)),
	    `LogView(`id(`log),
		     _("Information about the activities"),
		     5,		// visible lines
		     500),	// lines to store,
	    `VSpacing( 0.2 )
	    );

  
  string help_text = "";

  // helptext  "Connection and Data transfer" 
  string help_part11 =  UI(_("<p>After connecting to SuSE server,
YaST2 will download all selected patches.
This could take some time. Several details are shown.</p>"));

  string help_part12 = UI(_("<p>YaST2 first gets the patch descriptions
from the patch CD.<br>
After that, all selected patches will be copied to the
hard disk.</p>
"));

  string help_part13 = UI(_("<p>YaST2 first gets the descriptions of
the available patches from the FTP/HTTP server.
After that, select the patches to
download and install.</p>
"));
  
  string help_part2 =  UI(_("<p>
The fields above show information about the connection and
time of data transfer.
The box below displays data from the FTP/HTTP log file. If something
goes wrong, check this file for information. 
</p>
"));
  string help_part3 =  UI(_("<p>
If you decide to <b>Abort Update</b>, the download of
patches will be interrupted. No patch will be installed.
The ftp/http connection will be closed. 
</p>"));

  if ( cd_update )
  {
      help_text = help_part12;
  }
  else if (auto_mode || continue_mode)
  {
      help_text = help_part11 + help_part2 + help_part3;
  }
  else
  {
      help_text = help_part13 + help_part2 + help_part3; 
  }

  //
  // show the dialog also for CD update (!continue_mode)
  // because it can take some time to copy the patch descriptions
  // and there could be a popup "YaST2 patches available". 
  //
  
  UI::SetWizardContents(_("Connection and Data transfer"), contents, help_text, Args(0), Args(1) );

  UI::ChangeWidget(`id(`id1), `Value, you_server);  
  UI::ChangeWidget(`id(`status), `Value, _("closed") );

  // Fake getting of patches for fake_mode (NOT USED)
  integer test_id = 0;
  global define FakeGetPatch( string patch) ``{
      integer counter = 0;
      string log = "";
      map result = $[];
      
      while (counter < 100)
      {
	  counter = counter + 1;
	  UI::ChangeWidget(`id(`log), `LastLine, "Neue Zeile ........\n" );
      }
      test_id = test_id + 1;
	 
      y2debug("ONLINE: Get patch %1 ( fake_mode ): %2", patch, test_id != 3 );

      if (test_id == 3)
      {
	  result = add(result, "ok", false );
	  string msg =  sformat( "Download failed for patch %1.\nReasons are unknown.", patch );
	  result = add( result, "message", msg );
      }
      else
      {
	  result = add(result, "ok", true );
	  string msg = sformat("Download successful for patch %1.\n", patch );
	  result = add( result, "message", msg );
      }
      result = add(result, "progress", test_id*10);
      result = add(result, "continue", false );
      
      return result;
  };

  // get patches from you server
  global define GetAllPatches( map new_patches ) ``{
      list ret_list = [];
      list patch_list = [];
      integer index = 0;
      boolean go_on = true;
      integer patch_no = 0;
      string batchkind = "";

      batchkind = lookup ( user_settings, "you_auto_batchkind", "all" );

      foreach( `patch, `patch_info, new_patches, ``{
	  // only get the patch if marked with "X" or "G" 
	  if ( select ( lookup(new_patches, patch, []), 3 ) == "X" || select ( lookup(new_patches, patch, []), 3 ) == "G")
	   {
	       if ( batchkind == "all" ||
		    batchkind == select ( lookup(new_patches, patch, []), 0 ) )
	       {
		   patch_list = add(patch_list, patch);
	       }
	   }
      });
      patch_no = size(patch_list);

      if ( patch_no == 0 )
      {
	  // nothing will do
	  return ret_list;
      }

      string connect_string = sformat ( UI(_("Starting download of selected patches from %1.\n")), you_server );
      UI::ChangeWidget(`id(`log), `LastLine, connect_string );

      map  result_map = SCR::Execute(.you.connect,"");
      y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result_map );
      connect_string = lookup (result_map, "message", "" );
      if ( size ( connect_string ) > 0 )
      {
	  UI::ChangeWidget(`id(`log), `LastLine, connect_string+"\n" );
      }
      if (lookup( result_map, "ok", false )  )
      {
	  UI::ChangeWidget(`id(`status), `Value, _("active"));
      }

      ShowProgress( 5 );

      string lastErrorServer = you_server; // only for error popup      
      
      while ( (index < patch_no) && go_on )
      {
	  map patch_result = $[];
	  string patch = select(patch_list, index);
	  
	  y2debug("Status of patch %1: %2", patch, select( lookup(new_patches, patch, []), 3 ));

	  UI::ChangeWidget(`id(`log), `LastLine, sformat( UI(_("Get packages for patch %1\n")), patch) );
	  
	  patch_result = SCR::Execute( .you.getPatch, select(patch_list, index) );
	  y2debug("ONLINE: SCR::Execute(.you.getPatch, %1 )): %2", select(patch_list, index), patch_result );
	  while ( lookup(patch_result, "ok", false) == true &&
		  lookup(patch_result, "nextPackage","") != "" )
	  {
	      boolean otherServerConnect = false;
	      y2debug("ONLINE: SCR::Execute(.you.getPatch, %1 )): %2",
		      select(patch_list, index), patch_result );  
	      UI::ChangeWidget(`id(`log), `LastLine, "Package " +
			    lookup(patch_result, "nextPackage","") +
			   "\n" );
	      UI::ChangeWidget(`id(`fileProgress), `ExpectedSize, lookup(patch_result, "nextPackageSize",0));
	      UI::ChangeWidget(`id(`fileProgress), `Filename, lookup(patch_result, "nextPackage",""));

	      string otherYouServer = lookup ( patch_result, "nextServer", "" );
	      string otherYouServerKind = lookup ( patch_result, "nextServerKind", "" );
	      string scriptName = "";

	      if ( lookup ( patch_result, "nextSerie", "" ) == "script" )
	      {
		  scriptName = lookup(patch_result, "nextPackage","");
	      }
	      
	      // Checking, if the package is on another server; not when the
	      // source is CD, Harddisk....
	      if ( you_serverkind != "local" &&
		   you_serverkind != "Net" &&
		   you_serverkind != "CD" &&
		   you_serverkind != "Harddisk" &&
		   size ( otherYouServer ) > 0 )
	      {
		  map result = $[];

		  otherServerConnect = true;
		  
		  // disconnect from the old server
		  result = SCR::Execute( .you.disconnect,"");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", result );
		  string last_logging = lookup(result, "message", "" );
		  if ( size ( last_logging ) > 0 )
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
		  }
		  if ( lookup( result, "ok", false )  )
		  {
		      UI::ChangeWidget(`id(`status), `Value, _("closed"));
		  }
		  
		  // connecting to other you-server

		  any retval = SCR::Execute( .you.setServer,
					     $["kind":otherYouServerKind,
					      "name":otherYouServerr,
					      "path":"."]);
		  y2debug("ONLINE: SCR::Execute(.you.setServer,( %1, %2 %3 ) ): %4",
			  otherYouServer, ".", otherYouServerKind, retval );
		
		  if (retval == nil || retval == false)
		  {
		      last_logging = sformat ( UI(_("Connection failed to %1\n")), otherYouServer );
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging );   
		  }
		  else
		  {
		      // connect to new server
		      result = SCR::Execute(.you.connect,"");
		      y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result );		      

		      string connect_string = lookup (result, "message", "" );
		      if ( size ( connect_string ) > 0 )
		      {
			  UI::ChangeWidget(`id(`log), `LastLine, connect_string+"\n" );
		      }
		      if (lookup( result, "ok", false )  )
		      {
			  UI::ChangeWidget(`id(`status), `Value, _("active"));
			  UI::ChangeWidget(`id(`id1), `Value, otherYouServer);  			  
		      }
		  }
	      }

	      // Getting rpm
	      patch_result = SCR::Execute( .you.getPatch, select(patch_list, index) );
	      y2debug("ONLINE: SCR::Execute(.you.getPatch, %1 )): %2", select(patch_list, index), patch_result );
	      
	      if ( !lookup(patch_result, "ok", false)  )
	      {
		  if ( otherServerConnect )
		  {
		      lastErrorServer = otherYouServer;
		  }
		  else
		  {
		      lastErrorServer = you_server;
		  }
	      }
	      
	      if ( otherServerConnect )
	      {
		  //Reconnect to old server
		  map result = $[];

		  otherServerConnect = false;
		  
		  // disconnect from  server
		  result = SCR::Execute( .you.disconnect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", result );
		  
		  string last_logging = lookup(result, "message", "" );
		  if ( size ( last_logging ) > 0 )
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
		  }
		  if ( lookup( result, "ok", false )  )
		  {
		      UI::ChangeWidget(`id(`status), `Value, _("closed"));
		  }
		  
		  // setting to old you-server
		  any retval = SCR::Execute( .you.setServer,
					 $["kind":you_serverkind, "name":you_server, "path":you_dir]);		  
		  if (retval == nil || retval == false)
		  {
		      last_logging = sformat ( UI(_("Connection failed to %1\n")), you_server );
		      UI::ChangeWidget(`id(`log), `LastLine, last_logging );    
		  }

		  // connect to old server
		  result = SCR::Execute(.you.connect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result );		      		  
		  if (lookup( result, "ok", false )  )
		  {
		      UI::ChangeWidget(`id(`status), `Value, _("active"));
		      UI::ChangeWidget(`id(`id1), `Value, you_server);   
		  }
	      }

	      if ( scriptName != ""
		   && select( lookup(new_patches, patch, []), 3 ) == "X" )
	      {
		  string command = "source " + scriptName;
		  
		  UI::ChangeWidget(`id(`log), `LastLine, "Execute script " + scriptName + "\n");
		  
		  integer doresult = SCR::Execute (.target.bash, command );

		  if (doresult==0)
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, "return ok\n");		      
		  }
		  else
		  {
		      UI::ChangeWidget(`id(`log), `LastLine, "return NOT ok\n");		      
		  }
	      }
	  }
	  
	  if ( !lookup(patch_result, "ok", false) )
	  {
	      // set status to error
	      SCR::Write(.you.patchUpdateStatus, select(patch_list, index), ERROR );
	      y2debug("ONLINE:  SCR::Write(.you.patchUpdateStatus,%1, %2)", select(patch_list, index), ERROR );
	      user_settings = add(user_settings, "you_ok", false );
	       
	      // put logging into LogView Widget before showing popup
	      string last_logging = lookup(patch_result, "message", "" );
	      if ( size ( last_logging ) > 0 )
	      {
		  UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
	      }

	      if (  !auto_mode_get )
	      {
		  string msg_str = sformat(UI(_("Can't get patch \"%1\" from
server \"%2\".
You may try to download remaining patches or
go on with installation of downloaded ones.
")),
					   select(patch_list, index), lastErrorServer );
	      
		  any ret = UI::DisplayMsgFtp( msg_str, _("Notify"), _("&Download"), _("&Install") );

		  if (!ret)
		  {
		      go_on = false;
		  }
	      }
	  }
	  else if ( select ( lookup(new_patches, patch, []), 3 ) == "X" )
	  {
	      // patches marked with "X" will be installed
	      if ( batchkind == "all" ||
		   batchkind == select ( lookup(new_patches, patch, []), 0 ) )
	      {
		  ret_list = add( ret_list, select(patch_list, index) );
	      }
	  }
	  
	  // put logging into LogView Widget
	  string log_string = lookup(patch_result, "message", "" );
	  if ( log_string != "" )
	  {
	      UI::ChangeWidget(`id(`log), `LastLine, log_string+"\n" );
	  }

	  // Polling input to give the user a chance to stop the download  
	  any r = UI::PollInput();
	  if ( r == `abort )
	  {
	      any ret = UI::DisplayMsgFtp( _("Download of patches will be stopped.
You may continue with installation of already
loaded patches or abort update completely."), _("Warning"), _("&Install"), _("&Abort"));
	      go_on = false;

	      if ( !ret )
	      {
		  // don't install any patches - finish the workflow
		  ret_list = [];
	      }
	      // else   stop loading and continue with installation of the patches
	  }
	  index = index+1;
	  if (((index*100)/patch_no) > 95 )
	  {
	      ShowProgress( 95 );	      
	  }
	  else
	  {
	      ShowProgress( (index*100)/patch_no );
	  }
      }
      
      ShowProgress( 0 );

      UI::ChangeWidget(`id(`fileProgress), `Filename, "");      
      UI::ChangeWidget(`id(`fileProgress), `ExpectedSize, 1024);
      
      // disconnect
      map result = SCR::Execute( .you.disconnect, "");
      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", result );      

      string last_logging = lookup(result, "message", "" );
      if ( size ( last_logging ) > 0 )
      {
	  UI::ChangeWidget(`id(`log), `LastLine, last_logging+"\n" );
      }
      if (lookup( result, "ok", false )  )
      {
	  UI::ChangeWidget(`id(`status), `Value, _("closed"));
      }
      
      return ret_list;
  };

  //
  // Checking packages for consistents and original SuSE-packages
  //
  global define checkPackages( list package_list, string patch ) ``{
      boolean install = true;
      boolean dontAsk = false;

      string tmpfile = SCR::Read(.run.mktemp);

      string gpg_warning = sformat(
				   UI(_("Cannot check patch %1 because the GPG key is not installed or is corrupted.
SuSE cannot guarantee that the packages has been created by SuSE.
")),
			       patch);
      
      list packageVersion = PKGINFO (`getPackageVersion("gpg"));
      if ( size ( packageVersion ) >= 0 &&
	   select( packageVersion, 0 ) == "not known" )
      {
	  // package gpg not found
	  gpg_warning = sformat(
		   UI(_("Cannot check patch %1 because the GPG package is not installed or is corrupted.
SuSE cannot guarantee that the packages has been created by SuSE.
")),
		   patch);
      }
      
      y2milestone ( "tmpfile : %1", tmpfile );
      foreach ( `package, package_list, ``{
	  integer ret_shell = SCR::Execute(.target.bash,
				"/bin/rpm --checksig " + package + " >" + tmpfile + " 2>>" + tmpfile );
	  if ( ret_shell != 0 )
	  {
	      if ( SCR ::Execute (.target.bash, "/bin/grep -i \"GPG NOT OK\" " + tmpfile ) == 0 )
	      {
		  boolean ret = true;

		  y2warning ( "package %1 returned gpg-error",
				package );
		  if ( !dontAsk )
		  {
		      ret = UI::DisplayMsgYou( gpg_warning, _("Warning"),
					       _("&Install"), _("&Don't install") );
		      if ( !ret )
		      {
			  install = false;
			  y2warning ( "installing anyway" );
		      }
		      dontAsk = true;
		  }
	      }
	      else
	      {
		  string message = sformat(
					   UI(_("Patch %1 will not be installed 
because package %2 is corrupted
")),
					   patch, package );
	      
		  y2error( "%1", message );
	      
		  UI::DisplayMsgYouOk( message, _("Error"), _("&ok") );
		  install = false;
	      }
	  }
	  else
	  {
	      // Checking, if gpg was available
	      if ( SCR::Execute (.target.bash, "/bin/grep -i \"GPG\" " + tmpfile ) != 0 )
	      {
		  y2warning ( "package %1 no gpg-key found",
				package );
		  
		  if ( !dontAsk )
		  {
		      boolean ret = true;
		      
		      ret = UI::DisplayMsgYou( gpg_warning, _("Warning"),
					       _("&Install"), _("&Don't install") );
		      if ( !ret )
		      {
			  install = false;
			  y2warning ( "installing anyway" );
		      }
		      dontAsk = true;
		  }
	      }
	  }
	  
	  SCR::Execute (.target.bash, "/bin/rm " + tmpfile );	  
      });
      
      return install;
  };

    
  //
  // InstallPatches
  // call inst_rpmcopy for every patch with list of packages belonging to the patch
  //
  global define InstallPatches( list patch_list ) ``{
      string pre_info = "";
      string post_info = "";
      integer no = 1;
      integer package_count = 0;

      // remove old rpm logging
      SCR::Execute(.target.bash, "/bin/rm /var/log/y2logRPMShort" );
      SCR::Execute(.target.bash, "/bin/rm /var/log/y2logRPM" );      
      
      foreach ( `patch, patch_list, ``{
	  symbol ret = nil;
	  boolean go_on  = true;
	  
	  map check_version = SCR::Execute (.you.checkYaST2Version, version,patch );
 	  if ( lookup ( check_version, "ok", true ) )
	  {
	      // correct YaST2 version
	      list package_list = [];
	      list info_list = [];
	      list desc_list = [];
	      info_list = SCR::Read(.you.packages, patch );

	      foreach (`pac, info_list , ``{
		  package_list = add ( package_list, select ( pac, 0 ) );
		  desc_list = add ( desc_list, select( pac, 1) );
	      });
	      
	      y2debug("ONLINE: SCR::Read(.you.packages %1 ): %2 %3",
		      patch,
		      package_list,
		      desc_list);
	      if ( checkPackages ( package_list, patch ) )
	      {
		  // packages are ok
		  
		  pre_info = SCR::Read(.you.preInstallInformation,  patch);

		  if ( pre_info != "" &&
		       !auto_mode_install )
		  {
		      string header = sformat(UI(_("Warning for patch %1")),
						    patch );
		      
		      go_on = UI::DisplayMsgYou( pre_info,
						 header,
						 _("&Install"),
						 _("&Skip patch"));

		      y2debug( "RREETTURRN: %1", go_on);
		  }
		  if ( go_on )
		  {
		      ret = CallFunction(`inst_rpmcopy(false, false,
						       package_list,
						       desc_list ));
		      y2debug("ONLINE: %1. call of inst_rpmcopy returns: %2",
			      no, ret );
		      package_count = package_count + size ( package_list );
		      no = no+1;
		      post_info = SCR::Read(.you.postInstallInformation,  patch);

		      if ( post_info != "" &&
			   !auto_mode_install )
		      {
			  string header = sformat(UI(_("Information for patch %1")),
						  patch );

			  go_on = UI::DisplayMsgYouOk( post_info,
				header,
				_("&Ok"));
		      }
		  }

		  // do not set error status - let patch status NEW
      
		  if (ret == `abort )
		  {
		      // set status to error
		      SCR::Write(.you.patchUpdateStatus, patch, ERROR );
		      y2debug("ONLINE:  SCR::Write(.you.patchUpdateStatus,%1, %2)",
			      patch, ERROR );		      

		      user_settings = add(user_settings, "you_ok", false );
		      // ********************* foreach abbrechen **************
		      return `cancel;
		  }
		  else if ( ret == `next )
		  {
		      // set status to INSTALLED
		      SCR::Write(.you.patchUpdateStatus, patch, INSTALLED );
		      y2debug("ONLINE:  SCR::Write(.you.patchUpdateStatus,%1, %2)",
			      patch, INSTALLED );		      
		  }
	      }
	  }
	  else
	  {
	      // not the correct YaST2 Verison
	      string message = sformat(
		UI(_("Patch %1 needs version %2 of YaST2.
You have installed version %3.
")),
		patch,
		lookup ( check_version, "minYaST2Version", "-" ),
		version );
	      UI::DisplayMsgYouOk( message, _("Warning"), _("Don't install") );
	  }
      });

      user_settings = add ( user_settings, "you_updated_packages",
			    package_count );
      
      return `ok;
  };

  //  
  // Several functions of SCR(.you....) return a map of result information, e.g. 
  // $[ "ok": "true", "continue": false, "progress":"20", "message":"Download successful" ]
  // (not all information is used on every call)
  //  
  map result_map = $[];
  map new_patches = $[];
  boolean go_on = true;
  boolean success = true;

  if ( !continue_mode &&
       !auto_mode_install )
  {
      // The patch-list only has to loaded from you-server when module is called first time
      // and not only install local available patches.

      string connect_string = sformat( UI(_("Starting download of patch descriptions from %1.\n")), you_server );
      UI::ChangeWidget(`id(`log), `LastLine, connect_string );

      if ( success )
      {
	  result_map = SCR::Execute(.you.connect, "");
	  y2debug("ONLINE:  SCR::Execute(.you.connect): %1", result_map );	  

	  success = lookup( result_map, "ok", false );
	  string last_logging = lookup(result_map, "message", "" );
	  if ( size ( last_logging ) > 0 )
	  {
	      UI::ChangeWidget(`id(`log),
			       `LastLine, last_logging+"\n" );
	  }
      }

      if (success)
      {
	  // Remove all patches with status .new or .error, because we want to download
	  // the actual (possibly improved) descriptions from server
	  //  [ "Distribution_Version":"7.2","Product_Version":"3.0", "Product_Name":"Email Server" ] 
	 
	  map productInfo = SCR::Read (.you.productInfo);
	  y2debug("ONLINE: productInfo: %1", productInfo);	  
	  string patch_path = "";

	  if ( SCR::Read (.you.isBusiness) )
	  {
	      patch_path = sformat("/var/lib/YaST/patches/%1/update/%2/%3/patches/",
				   lookup(user_settings, "architecture", "i386"),
				   lookup( productInfo, "Product_Name", "" ),
				   lookup( productInfo, "Product_Version", "" ));
	  }
	  else
	  {
	      patch_path = sformat("/var/lib/YaST/patches/%1/update/%2/patches/",
				   lookup(user_settings, "architecture", "i386"),
				   lookup( productInfo, "Distribution_Version", "" ));
	  }
	  
	  string rm_files = patch_path + "*.new";
	  y2debug("ONLINE: patch file path %1", patch_path);
	  integer ret = SCR::Execute(.target.bash, sformat("rm -rf %1", rm_files ));
	  rm_files = patch_path + "*.error";
	  SCR::Execute(.target.bash, sformat("rm -rf %1", rm_files ));
	  
	  UI::ChangeWidget(`id(`status), `Value, _("active"));
	  while (go_on)
	  {
	      //get list of patches step by step
	      result_map = SCR::Execute(.you.getPatchList, ""); 
	      y2debug("ONLINE: SCR::Execute(.you.getPatchList) : %1", result_map );

	      go_on = lookup (result_map, "continue", false );

	      string message = lookup (result_map, "message", "" );
	      if ( message != "" )
	      {
		  UI::ChangeWidget(`id(`log), `LastLine, message +"\n" );
	      }
	      if ( lookup( result_map, "checkpatch" , "" ) != "" )
	      {
		  // checking gpg-key
		  string patchpath = lookup( result_map, "checkpatch" , "" );

		  string command = "/usr/bin/gpg -o " + patchpath
		      + ".unpack " + patchpath;
		  integer doresult = SCR::Execute (.target.bash, command );

		  if (doresult==0)
		  {
		      // check has been ok
		      SCR::Execute (.target.bash, "/bin/cp "
				    + patchpath
				    + ".unpack "
				    + patchpath );	  		  
		  }
		  else
		  {
		      string gpg_warning = sformat(
					    UI(_("Cannot check patch %1 because the GPG package is not installed
or the patchdescription is corrupted.
SuSE cannot guarantee that the patch has been created by SuSE.
")),
					    message);		      
		      // not ok
		      boolean ret = UI::DisplayMsgYou( gpg_warning, _("Warning"),
					       _("&Install"), _("&Don't install") );
		      if ( ret )
		      {
			  // Does not matter
			  SCR::Execute (.target.bash, "/bin/cp "
					+ patchpath
					+ ".unpack "
					+ patchpath );	  		  

			  y2warning ( "installing anyway" );
		      }
		      else
		      {
			  // removing patch
			  SCR::Execute (.target.bash, "/bin/rm "
					+ patchpath );
			  
		      }
		  }
		  SCR::Execute (.target.bash, "/bin/rm "
				+patchpath
				+ ".unpack"   );	  		  
	      }

	      ShowProgress( lookup (result_map, "progress", 0 ) );
	  }
	  
	  success = lookup( result_map, "ok", false );
      }
      else
      {
	  
	  UI::ChangeWidget(`id(`log), `LastLine,
			   lookup (result_map, "message", "" ) ); 

	  if ( !auto_mode_get )
	  {
	      // Error popup if youConnect failed -
	      // Patch CD udpate: no CD in drive, mount failed
	      // Online Update: connecting to you server failed
	  
	      //if ( lookup( user_settings, "you_server", "" ) == "CD" )
	      if ( cd_update )
	      {
		  UI::MessagePopup(_("Can't get the patch descriptions.
Please insert SuSE patch CD and
restart the \"Patch CD Update\".
"));
		  return `abort;
	      }
	      else
	      {
		  UI::MessagePopup(_("Connection to YOU server failed.
Try to connect to another SuSE FTP/HTTP server.
"));
		  return `back;  
	      }
	  }
	  else
	  {
	      SCR::Execute(.you.closeUpdate, false); 
	      return `abort;	      
	  }
      }

      // disconnect
      map disconnect_map = SCR::Execute( .you.disconnect, "");
      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );
  
      if ( lookup(disconnect_map, "ok", false ) )
      {
	  UI::ChangeWidget(`id(`status), `Value, _("closed"));
      }

      string disconnect_message = lookup (disconnect_map, "message", "" );
      if ( size ( disconnect_message ) > 0 )
      {
	  UI::ChangeWidget(`id(`log), `LastLine, disconnect_message +"\n" );
      }

      ShowProgress( 0 );      
  }
  
  if (success)
  {
      new_patches = SCR::Read(.you.newPatchList);
      y2debug( "ONLINE: Reading patch data: %1", new_patches );
  }
  else
  {
      // Error popup if youGetPatchList failed -
      // Patch CD update: wrong CD in drive (path must be: <architecture>/update/<version>
      // Online Update: path on you server not found

      if ( !auto_mode_get &&
	   !auto_mode_install )
      {
	  if ( cd_update )
	  {
	      UI::MessagePopup(_("Can't get the patches from CD.
Please insert the SuSE patch CD
(check the version)
or update your system with YaST2
\"Online Update\".
")); 
	      return `abort;
	  }
	  else
	  {
	      UI::MessagePopup(_("Can't get the patches from server.
Please try to get patches from another SuSE FTP/HTTP server.
"));   
	      return `back;
	  }
      }
  }

  if ( !continue_mode &&
       !auto_mode_get &&
       !auto_mode_install )
  {
      // Evaluate, if there are YaST2 packages which have to be
      // updated first

      boolean yast2found = false;
      boolean notyast2found = false;
      map yast2map = $[];
      foreach( `patch, `patch_info, new_patches, ``{
	  if (  select ( patch_info, 3 ) == "X" &&
		select ( patch_info, 0 ) == "YaST2" )
	  {
	      yast2found = true;
	      yast2map = add ( yast2map, patch, patch_info );
	  }
	  else
	  {
	      if ( select ( patch_info, 3 ) == "X" )
	      {
		  notyast2found = true;
	      }
	      list dummy = [];
	      dummy = add ( dummy, select ( patch_info, 0 ) );
	      dummy = add ( dummy, select ( patch_info, 1 ) );
	      dummy = add ( dummy, select ( patch_info, 2 ) );
	      dummy = add ( dummy, " " );
	      yast2map = add ( yast2map, patch, dummy );
	  }
      });

      if ( yast2found && notyast2found )
      {
	  new_patches = yast2map;
	  y2milestone( " YaST2 patches found; only install %1",
		       new_patches );
	  // Message popup text: YaST2 patches found which should be installed first
	  UI::MessagePopup(_("There are YaST2 patches available.
These patches should be installed first.
Please install these patches then run the YaST2 Online Update
again to install the rest of the packages.
"));
      }
  }
  
  if ( auto_mode )
  {
      if ( !auto_mode_get &&
	   !auto_mode_install )
      {
	  // calculate required download size
	  integer disk_size = 0;
	  foreach( `patch, `patch_info, new_patches, ``{
	      disk_size = disk_size + tointeger(
						select ( lookup(new_patches, patch, []), 2 ) )*1024;
	  });

	  if ( disk_size > 1000000 )
	  {
	      // only greater than 1 MB
	      string message = sformat (
		UI(_("There are %1 patches on FTP/HTTP. Downloading may take a while.
 Do you really want to download the patches now?
")),
		size_text( disk_size ) );

	      if ( !UI::AnyQuestionPopup( "", message ,YesButtonLabel(), NoButtonLabel(), `yes_default) )
	      {
		  return `abort;		// abort update	      
	      }
	  }
      }

      list install_patches = [];
      
      if ( auto_mode_install )
      {
	  string batchkind = lookup ( user_settings, "you_auto_batchkind", "all" );
	  // only use patches which already have been loaded from server
	  foreach( `patch, `patch_info, new_patches, ``{
	      // only get the patch if marked with "X" or "G" 
	      if ( select ( lookup(new_patches, patch, []), 3 ) == "X" ||
		   select ( lookup(new_patches, patch, []), 3 ) == "G")
	      {
		  if ( batchkind == "all" ||
		       batchkind == select ( lookup(new_patches, patch, []), 0 ) )
		  {
		      install_patches = add(install_patches, patch);
		  }
	      }
	  });	  
      }
      else
      {
	  // get the patches
	  install_patches = GetAllPatches( new_patches );
      }

      if ( !auto_mode_get )
      {
	  if ( size (install_patches) >0 )
	  {
	      y2debug( "ONLINE: automatic mode, installing: %1", install_patches );

	      // go on and install all available patches in auto_mode
	      any ret = InstallPatches( install_patches );
	      return `next;
	  }
	  else
	  {
	      if ( !auto_mode_install )
	      {
		  any ret = SCR::Execute( .you.disconnect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", ret );

		  UI::MessagePopup(_("There is no patch to install."));
	      }
	      return `abort;		// abort update
	  }
      }
      else
      {
	  // Patches has been get only; Finish you update
	  y2debug("ONLINE: close update with status: %1", lookup(user_settings, "you_ok", false) );
	  SCR::Execute(.you.closeUpdate, lookup(user_settings, "you_ok", false)); 	  
	  return `abort;
      }
  }
  else if ( !continue_mode )
  {
      // write new_patches to user_settings -> table input online_update_select
      user_settings = add(user_settings, "you_patches", new_patches );
      y2debug( "Wrote list of new patches to user_settings: %1", new_patches );

      // prepare for second call in manual mode 
      user_settings = add(user_settings, "you_continue", true );

      // got patches and write new_patches to user_settings -> go `next if CD update
      if ( cd_update )
	  return `next;
  }
  else if ( continue_mode )
  {
      // get selected patches (written to user_settings from online_update_select)
      map get_patches = lookup( user_settings, "you_patches", $[] );

      list install_patches = GetAllPatches( get_patches );

      if ( size ( install_patches ) > 0 )
      {
	  y2debug( "ONLINE: manual mode, installing: %1", install_patches );

	  while (true)
	  {
	      any r = UI::UserInput();
	      if ( r == `next )
	      {
		  // install selected patches
		  any ret = InstallPatches( install_patches );
		  return `next;
	      }
	      else if ( r == `abort  && UI::ConfirmAbortUpdate(`incomplete) )
	      {
		  // set CloseUpdate status to false (installation NOT complete)
		  SCR::Execute(.you.closeUpdate, false);
		  map disconnect_map = SCR::Execute(.you.disconnect, "");
		  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  
		  return `abort;	// abort update
	      }
	  }
      }
      else
      {
	  // do not set the CloseUpdate status -> no patch is installed
	  map disconnect_map = SCR::Execute(.you.disconnect, "");
	  y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  	  
	  UI::MessagePopup(_("No patch will be installed."));

	  return `finish;
	  //return `abort;
      }
  }
  else
  {
      map disconnect_map = SCR::Execute(.you.disconnect, "");
      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  	  
      
      y2error("online_update_load - mode not set");
      return `abort;
  }
	 
	 
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////  Loop for User Input ....
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////
  symbol ret = `next;

  repeat
      {
	  ret= UI::UserInput();

	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  ////  FINISH
	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if ( ret == `abort && UI::ConfirmAbortUpdate(`incomplete) )
	  {
	      map disconnect_map = SCR::Execute(.you.disconnect, "");
	      y2debug("ONLINE:  SCR::Execute(.you.disconnect): %1", disconnect_map );		  	  

	      return `abort;
	  }

	  ////////////////////////////////////////////////////////////////////////////////////////////////////////
	  ////  
	  ////////////////////////////////////////////////////////////////////////////////////////////////////////

	  if ( ret == `back)
	  {
	      // RESET continue mode
	      user_settings = add(user_settings, "you_continue", false );
	  }

      } until (ret == `next || ret == `back || ret == `cancel);

  y2debug("online_update_load Return: %1", ret );
  return ret;
}



