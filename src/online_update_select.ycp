/*
 *************************************************************
 *
 *     YaST2      SuSE Labs                        -o)
 *     --------------------                        /\\
 *                                                _\_v
 *           www.suse.de / www.suse.com
 * ----------------------------------------------------------
 *
 * Author:        Gabriele Strattner <gs@suse.de>
 *
 * Purpose:	Dialog displays a list with all available patches.
 *		The user can select or deselect patches for download.
 *		Patches marked with "X" will be installed afterwards,
 *		patches marked with "G" will be downloaded, but not
 *		installed because they are not relevant for the system.
 *		
 * Modify:	
 *
 * external function:
 *
 *
 *************************************************************

 $Id$

*/

{
  textdomain "online_update";
  
    // Testmode
    boolean test_mode    = lookup ( user_settings, "test_mode", false );

    boolean cd_update 	= lookup( user_settings, "cd_update", false );
      
    // map you_patches contains information about all available patches, e.g.
    //
    // $["patch-001":["recommended", "Patch for NFS server", "234", "X"],
    //   "patch-002":["security", "Noch ein weiterer patch", "565", " "]];
    //
    // status information from all patches must be stored, because if the user
    // deselects a patch and selects it again we must know whether it was "X" or "G"
    map all_patches = lookup( user_settings, "you_patches", $[] );
    y2debug("ONLINE: %1", all_patches );
    
    // if the user doesn't do any changes and the current YaST2 has the right versin, the user
    // get all patches
    map get_patches = $[];
    maplist ( `patch, `value,  all_patches, ``(
    {
	// checking YaST2-version
	map check_version = SCR::Execute( .you.checkYaST2Version, version, patch);
	if ( lookup ( check_version, "ok", true ) )
	{
	    get_patches = add ( get_patches, patch, value );
	}
    }));

    
    //////////////////////////////////////////////////////////////////////////////////////
    //  Popups and Defines			                                        //
    //////////////////////////////////////////////////////////////////////////////////////

    // update map get_patches and change status in list

    global define UpdateGetPatches ( string pname, string pstatus, string mode ) ``{

	maplist ( `patch, `value,  get_patches, ``(
	              {  if ( patch == pname )
		      {
			  if ( mode == "document" &&
			       ( pstatus == "X" || pstatus == "G" ))
			  {
      			      UI::ChangeWidget(`id(`patch_table), `Item( patch, 0 ), " ok" );
			      get_patches = add( get_patches, patch, [select(value, 0), select(value,1), select(value,2 ), "X"] );			      
			  }
			  else
			  {
			      UI::ChangeWidget(`id(`patch_table), `Item( patch, 0 ), sformat( " %1 ", pstatus ));
			  get_patches = add( get_patches, patch, [select(value, 0), select(value,1), select(value,2 ), pstatus] );
			  }
		      }
		      }));
    };
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    // MAIN:
    /////////////////////////////////////////////////////////////////////////////////////////////////////

  
    
    // create table input, e.g.
    // [`item(`id(patch-001), " X ", "recommended", "patch1", "356", "Patch for NFS server"),
    //  `item(`id(patch-002), "   ", "security", "patch2", "2560", "Noch ein weiterer patch") ];
    //
    list table_contents = maplist( `key, `value, all_patches,
				   ``(`item(`id(key),
					    sformat( " %1 ", select(value, 3) ),
					    select(value,0),
					    key,
					    format_size_text( tointeger(select(value,2))*1024 ),
					    select(value,1))
				      )
				   );

    term contents =
	    // main dialog: 
	`VBox(
	      `VSpacing( 0.2 ),
	       `Table(`id(`patch_table),`opt(`notify, `hvstretch), 
		      `header( " ", _("Mode"), _("Patch"), _("Size"), _("Description") ),
		      table_contents
			      ),
	      `HBox(`Left(`PushButton(`id(`apply), _("&Apply"))),
		    `Left(`PushButton(`id(`info), _("&Show description ...")))
		    ),
	      `VSpacing( 0.2 )
	      );
    
    string help_text = "";

    // Helptext  "List of available patches"
    // This text is shown if patches will be installed from CD.
    string help_part01 = UI(_("<p>This dialog shows the patches from the
SuSE Patch CD that are not yet installed on your system.</p>
"));
    // This is the text for you installation.
    string help_part02 =  UI(_("<p>This dialog shows all new patches available
for download from the SuSE FTP/HTTP server.</p>
"));
    // Don't translate "recommended" and "security". The patch mode is shown in a list
    // and will always be english text.
    string help_part1 = UI(_("<p>Mode \"recommended\" means you should install the patch.
\"security\" is a security patch and it is highly recommended to install it.
\"YaST2\" patches will be always installed first, other patches will be only
downloaded and must be installed on a second run.
</p>"));
    
    string help_part2 =  UI(_("<p>Meaning of the status flags:</p>
<p>
<b>X</b>: Patches concerning your installation are preselected.
They will be downloaded and installed on your system.
If you do not want a certain patch, double-click
the line to deselect it (or select the line and use Alt + A).
</p>
"));

    string help_part3 =  UI(_("<p>
<b>G</b>: patch is available but not relevant for your installation
(concerns packages which are not installed).
You can download the patch but it will not be installed.
</p>"));
    
    string help_part4 = UI(_("<p>
<b>_</b>: This patch is not selected. It will not
be downloaded or installed. To select the patch,
double-click the line (or select it and use Alt + A).
</p>
"));

    if ( cd_update )
    {
	help_text = help_part01 + help_part1 + help_part2 + help_part3 + help_part4;
    }
    else
    {
	help_text = help_part02 + help_part1 + help_part2 + help_part3 + help_part4;
    }
    
    // using SetContents (define in online_update.ycp)
    UI::SetWizardContents(_("List of available patches"), contents, help_text, Args(0), Args(1) );

      
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////  Loop for User Input ....
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    symbol ret = `next;

    repeat {

	ret= UI::UserInput();

	if ( ret == `abort && UI::ConfirmAbortUpdate(`unusable) )
	{
	    SCR::Execute (.you.disconnect);
	    return `abort;
	}
	if (ret == `patch_table || ret == `apply)
	{
	    any id = UI::QueryWidget(`id(`patch_table), `CurrentItem );
	    term  patch_info = UI::QueryWidget(`id(`patch_table), `Item(id));
	    y2debug("PATCHINFO: %1", patch_info);

	    string patch_name = select(patch_info, 3);
	    y2debug("Status of selected patch %1: %2",  patch_name, select( lookup( all_patches, patch_name, []), 3 ));

	    if ( select( patch_info, 1 ) == " X " ||
		 select( patch_info, 1 ) == " ok" )
	    {
		// mark patch deselected
		UpdateGetPatches( patch_name, " " , select ( patch_info, 2 ));
	    }
	    else if ( select( lookup( all_patches, patch_name, []), 3 ) == "X" )
	    {
		string pre_info = SCR::Read( .you.preInstallInformation, patch_name);
		boolean go_on = true;

		if ( pre_info != "" )
		{
		    string header = sformat(UI(_("Warning for patch %1")),
					    patch_name );
		      
		    go_on = UI::DisplayMsgYou( pre_info,
					       header,
					       _("&Install"),
					       _("&Skip patch"));

		    y2debug( "RREETTURRN: %1", go_on);
		}

		if ( go_on )
		{
		    map check_version = SCR::Execute( .you.checkYaST2Version, version,patch_name);
		    if ( lookup ( check_version, "ok", true ) )
		    {
			// was "X" before -> mark with "X" again
			UpdateGetPatches( patch_name, "X" ,select ( patch_info, 2 ) );
		    }
		    else
		    {
			string message = sformat(
			 UI(_("This patch needs the version %1 of YaST2.\nYou have installed version %2")),
			lookup ( check_version, "minYaST2Version", "-" ), version );
			UI::DisplayMsgYouOk( message, ErrorMsg(), _("Don't install") );
		    }
		}
	    }
	    else if ( select( lookup( all_patches, patch_name, []), 3 ) == " " )
	    {
		map check_version = SCR::Execute( .you.checkYaST2Version, version,patch_name);
		if ( lookup ( check_version, "ok", true ) )
		{
		    if ( select( patch_info, 1 ) == " G " )
		    {
			// was "G" before -> mark with "X"
			UpdateGetPatches( patch_name, "X" ,select ( patch_info, 2 ) );	
		    }
		    else
		    {
			// was not "X" and not "G" before -> mark with "G"
			string pre_info = SCR::Read( .you.preInstallInformation, patch_name);
			boolean go_on = true;

			if ( pre_info != "" )
			{
			    string header = sformat(UI(_("Warning for patch %1")),
						    patch_name );
		      
			    go_on = UI::DisplayMsgYou( pre_info,
						       header,
						       _("&Install"),
						       _("&Skip patch"));

			    y2debug( "RREETTURRN: %1", go_on);
			}

			if ( go_on )
			{
			    UpdateGetPatches( patch_name, "G" ,select ( patch_info, 2 ) );
			}
		    }
		}
		else
		{
		    string message = sformat(
			UI(_("This patch needs the version %1 of YaST2.\nYou have installed version %2")),
			lookup ( check_version, "minYaST2Version", "-" ), version );
		    UI::DisplayMsgYouOk( message, ErrorMsg(), _("Don't install") );
		}
	    }
	}
	else if ( ret == `info )
	{
	    string patch = UI::QueryWidget(`id(`patch_table), `CurrentItem );
	    ShowPatchInfo( patch );
	}
	else if (ret == `next)
	{
	    y2debug("ONLINE: get patches: %1", get_patches );

	    // write patch info to user_settings
	    user_settings = add(user_settings, "you_patches", get_patches);
	}

	if ( ret == `back)
	{

	}

    } until (ret == `next || ret == `back || ret == `cancel || ret == `abort);
    
   return ret;
}



