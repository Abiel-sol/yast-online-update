/**
 * Package:	online-update
 * Summary:	Call YOU during installation
 * Authors:	Arvin Schnell <arvin@suse.de>
 */
{

    textdomain "online-update";

    import "Directory";
    import "FileUtils";
    import "GetInstArgs";
    import "Internet";
    import "Mode";
    import "OnlineUpdateCallbacks";
    import "PackageCallbacksInit";
    import "Popup";
    import "ProductControl";
    import "ProductFeatures";
    import "Stage";
    import "Wizard";

    string saved_path		= Directory::vardir + "/selected_patches.ycp";
    string restart_data_file	= Directory::vardir + "/continue_installation";

    /* Called backwards */
    if(GetInstArgs::going_back())
            return `auto;

    boolean after_restart	= false;
    if (FileUtils::Exists (restart_data_file))
    {
	map restarting_step	= ProductControl::RestartingStep ();
	if (restarting_step["name"]:"" == "you")
	{
	    y2milestone ("installation restarted from YOU");
	    after_restart	= true;
	}
    }

    if (!Internet::do_you && !after_restart)	// nothing to do
	return `auto;

    // I have a feeling that we may need a lot of hacks here
    // to make things work
    boolean Hack (string what) {
	boolean hack = (SCR::Read (.target.size, "/tmp/hack-" + what) != -1);
	if (hack)
	    y2milestone ("HACK: %1", what);
	return hack;
    }

    /**
     * parse-metadata, the helper called by rug that actually adds the source,
     * runs asynchronously. So we wait for it to tell us "go" by creating
     * a file.
     */
    void WaitForSources () {
	// The name must be same in:
	// inst_you.ycp
	// inst_suse_register.ycp
	// svn/zypp/trunk/backend/src/parse-metadata.cc
	string flag_file = "/var/lib/zypp/zmd_updated_the_sources";
	integer a_second = 1000;
	integer count = 0;
	while (true)
	{
	    if (Hack ("nowait"))
		break;
	    if (SCR::Read (.target.size, flag_file) != -1)
		break;
	    // half an hour must be enough, prevents infinite loop
	    if (count >= 1800) {
		y2milestone ("Giving up.");
		break;
	    }
	    if (count % 30 == 0)
		y2milestone ("Waiting for %1 to appear.", flag_file);
	    sleep (a_second);
	    count = count + 1;
	}
	SCR::Execute (.target.remove, flag_file);
    }

    boolean already_up = false;
    if (!Mode::test())
        already_up = Internet::Status ();

    boolean i_set_demand = false;

    if (!already_up)
    {
	Wizard::SetContents (_("YaST2\nInitializing ..."), `Empty (), "", true, true);

	if (!Internet::demand)
	{
	    Internet::SetDemand (true);
	    i_set_demand = true;
	}

	Internet::Start ("");

	integer i = 150;
	while (i > 0)
	{
	    if (!Internet::Status ())
		break;

	    if (Internet::Connected ())
		break;

	    // ping anything (www.suse.com) to trigger dod connections
	    SCR::Execute (.target.bash_background,
			  "/bin/ping -c 1 -w 1 213.95.15.200");

	    sleep (1000);
	}
    }

    symbol ret = `auto;

    // initalize package callbacks
    PackageCallbacksInit::InitPackageCallbacks();

    if (Hack ("start"))		// not needed after all
    {
	WaitForSources ();
	// restore after inst_suse_register shut zypp down by Pkg::Init
	Pkg::TargetInit ("/", false);
	Pkg::SourceStartManager(true);
    }
    else if (after_restart)
    {
	Pkg::TargetInit ("/", false);
	Pkg::SourceStartManager(true);
    }

    // do snapshot of YaST and kernel packages
    list<string> packages = Pkg::GetPackages (`installed, false);
    list<string> kernel_packages = filter (string p, packages, {
	return substring (p, 0, 6) == "kernel";
    });
    list<string> yast2_packages = filter (string p, packages, {
	return substring (p, 0, 5) == "yast2";
    });
    y2milestone ("Kernel packages before YOU: %1", kernel_packages);
    y2milestone ("YaST packages before YOU: %1", yast2_packages);

    // compute ResStatus::EstablishField
    Pkg::PkgEstablish ();

    integer selected	= 0;

    // check if there exists saved selection of patches to be installed
    if (FileUtils::Exists (saved_path))
    {
	list<string> patches = (list<string>) SCR::Read(.target.ycp,saved_path);
	if (patches == nil)
	    patches = [];
	foreach (string pname, patches, {
	    if (Pkg::ResolvableInstall (pname, `patch))
		selected	= selected + 1;
	});
	SCR::Execute (.target.remove, saved_path);
	y2milestone ("Previously selected patches: %1", selected);
    }
    // if not, select the patches affecting pkg management
    else
    {
	selected = Pkg::ResolvablePreselectPatches (`affects_pkg_manager);
	y2milestone ("Preselected patches for pkg management: %1", selected);
    }

    // if no patch is selected, pre-select all security and recommended
    if (selected < 1)
    {
	selected = Pkg::ResolvablePreselectPatches (`all);
	y2milestone ("All preselected patches: %1", selected);
    }

    // run package selector to allow user interaction
    if (!Pkg::PkgSolve (false) ||
	ProductFeatures::GetBooleanFeature("globals", "manual_online_update") ||
	Hack ("ui"))
    {
	UI::OpenDialog(`opt(`defaultsize), `PackageSelector(`id(`selector), `opt(`youMode)) );
	symbol ret_sel = (symbol)UI::RunPkgSelection(`id(`selector) );
	UI::CloseDialog();
	if (ret_sel == `cancel)
	    return `next;
    }

    list<string> normal_patches		= [];
    boolean reboot_needed		= false;
    foreach (map patch, Pkg::ResolvableProperties("", `patch, ""), {
	if (patch["status"]:`none == `selected)
	{
	    y2milestone ("selected patch: %1", patch);
	    if (patch["affects_pkg_manager"]:false)
	    {
		if (patch["reboot_needed"]:false)
		    ret	= `reboot;
		else if (ret != `reboot)
		    ret	= `restart_same_step;
	    }
	    else
	    {
		normal_patches = add (normal_patches, patch["name"]:"");
		// for this patch reboot would be needed, but still it is not
		// clear if the patch will be installed in this run -> save info
		if (patch["reboot_needed"]:false)
		    reboot_needed	= true;
	    }
	}
    });

    // unselect non-affects_pkg_manager patches and save them to file
    // for later usage
    if (ret != `auto && size (normal_patches) > 0)
    {
	foreach (string pname, normal_patches, {
	    Pkg::ResolvableNeutral (pname, `patch, true);
	});
	SCR::Write (.target.ycp, saved_path, normal_patches);
    }
    // no packagemanager patch selected ...
    if (ret == `auto)
    {
	// ... but there is a patch with "reboot_needed" flag (=probably kernel)
	if (reboot_needed)
	    ret     = `reboot;
	// ... and nothing to install -> skip the installation at all
	else if (normal_patches == [] && !Pkg::PkgAnyToInstall () &&
	    !Pkg::PkgAnyToDelete ())
	    return `next;
    }


    // install the patches
    OnlineUpdateCallbacks::RegisterOnlineUpdateCallbacks();
    WFM::call( "online_update_install" );


    // check whether there are changes in the list
    packages = Pkg::GetPackages (`installed, false);
    list<string> new_yast2_packages = filter (string p, packages, {
	return substring (p, 0, 5) == "yast2";
    });
    y2milestone ("YaST packages after YOU: %1", new_yast2_packages);
    // check removed YaST packages, eventually added don't cause problem
    // of course it covers updated (one removed, another added)
    foreach (string p, yast2_packages, {
	if (! contains (new_yast2_packages, p))
	    y2internal ("yast package updated, current ret is %1", ret);
    });
    list<string> new_kernel_packages = filter (string p, packages, {
	return substring (p, 0, 6) == "kernel";
    });
    y2milestone ("Kernel packages after YOU: %1", kernel_packages);
    // check for added kernels, covers updates
    foreach (string p, new_kernel_packages, {
	if (! contains (kernel_packages, p))
	    y2internal ("kernel updated, current ret is %1", ret);
    });
    y2milestone ("Checking result: %1", ret);
    if (ret == `reboot)
    {
	// message popup
	Popup::Message (_("The kernel has been updated. The system will
reboot now then continue the installation.
"));
    }
    else if (ret == `restart_same_step)
    {
	// message popup
	Popup::Message (_("During online update, YaST was updated.
Finishing and restarting now."));
    }

    if (!already_up)
    {
	Internet::Stop ("");

	if (i_set_demand)
	{
	    Internet::SetDemand (false);
	}
    }

    return ret;
}
