/**
 * Package:	online-update
 * Summary:	Call YOU during installation
 * Authors:	Arvin Schnell <arvin@suse.de>
 */
{

    textdomain "online-update";

    import "Directory";
    import "FileUtils";
    import "GetInstArgs";
    import "Internet";
    import "Label";
    import "Mode";
    import "OnlineUpdate";
    import "OnlineUpdateCallbacks";
    import "PackageCallbacksInit";
    import "Popup";
    import "ProductControl";
    import "ProductFeatures";
    import "Stage";
    import "Wizard";

    string saved_path		= Directory::vardir + "/selected_patches.ycp";
    string restarted_path	= Directory::vardir + "/continue_you";

    /* Called backwards */
    if(GetInstArgs::going_back())
    {
	y2milestone ("going_back -> returning `auto");
        return `auto;
    }

    boolean after_restart	= false;
    if (FileUtils::Exists (restarted_path))
    {
	y2milestone ("installation restarted from YOU");
	SCR::Execute (.target.remove, restarted_path);
	after_restart	= true;
    }

    if (!Internet::do_you && !after_restart)	// nothing to do
    {
	y2milestone ("Internet::do_you is false -> `auto");
	return `auto;
    }

    // I have a feeling that we may need a lot of hacks here
    // to make things work
    boolean Hack (string what) {
	boolean hack = (SCR::Read (.target.size, "/tmp/hack-" + what) != -1);
	if (hack)
	    y2milestone ("HACK: %1", what);
	return hack;
    }

    boolean already_up = false;
    if (!Mode::test())
        already_up = Internet::Status ();

    boolean i_set_demand = false;

    if (!already_up)
    {
	Wizard::SetContents (_("YaST2\nInitializing ..."), `Empty (), "", true, true);

	if (!Internet::demand)
	{
	    Internet::SetDemand (true);
	    i_set_demand = true;
	}

	Internet::Start ("");

	integer i = 150;
	while (i > 0)
	{
	    if (!Internet::Status ())
		break;

	    if (Internet::Connected ())
		break;

	    // ping anything (www.suse.com) to trigger dod connections
	    SCR::Execute (.target.bash_background,
			  "/bin/ping -c 1 -w 1 213.95.15.200");

	    sleep (1000);
	    i	= i - 1;
	}
	if (i < 1)
	{
	    y2warning ("Internet::Status timed out, no connection available?");
	}
    }

    symbol ret = `auto;

    // initalize package callbacks
    PackageCallbacksInit::InitPackageCallbacks();

    if (after_restart || Hack ("init-target-and-sources"))
    {
	Pkg::TargetInit ("/", false);
	Pkg::SourceStartManager(true);
	// compute ResStatus::EstablishField (only after restart,
	// otherwise it was already done in inst_ask_online_update.ycp)
	Pkg::PkgEstablish ();
    }
    else // reinitialize target after release notes were read (#232247)
    {
	Pkg::TargetFinish ();
	Pkg::TargetInitialize ("/");
	Pkg::TargetLoad ();
    }

    integer selected	= 0;
    boolean check_licenses	= false;
    list neutralized	= [];

    // check if there exists saved selection of patches to be installed
    if (FileUtils::Exists (saved_path))
    {
	list<string> patches = (list<string>) SCR::Read(.target.ycp,saved_path);
	if (patches == nil)
	    patches = [];
	foreach (string pname, patches, {
	    if (Pkg::ResolvableInstall (pname, `patch))
		selected	= selected + 1;
	});
	SCR::Execute (.target.remove, saved_path);
	y2milestone ("Previously selected patches: %1", selected);
    }
    // if not, select the patches affecting pkg management
    else
    {
	selected = Pkg::ResolvablePreselectPatches (`affects_pkg_manager);
	y2milestone ("Preselected patches for pkg management: %1", selected);
    }

    // if no patch is selected, pre-select all security and recommended
    if (selected < 1)
    {
	selected = Pkg::ResolvablePreselectPatches (`all);
	y2milestone ("All preselected patches: %1", selected);
    }

    // run package selector to allow user interaction
    if (!Pkg::PkgSolve (false) ||
	ProductFeatures::GetBooleanFeature("globals", "manual_online_update") ||
	Hack ("ui"))
    {
	Pkg::TargetInitDU([]); // init DiskUsage counter (#197497)
	UI::OpenDialog(`opt(`defaultsize), `PackageSelector(`id(`selector), `opt(`youMode)) );
	symbol ret_sel = (symbol)UI::RunPkgSelection(`id(`selector) );
	UI::CloseDialog();
	if (ret_sel == `cancel)
	{
	    y2milestone ("package selector canceled -> `next");
	    return `next;
	}
    }
    else if (selected > 0)
    {
	check_licenses	= true;
    }

    list<string> normal_patches		= [];
    boolean reboot_needed		= false;
    foreach (map patch, Pkg::ResolvableProperties("", `patch, ""), {
	if (patch["status"]:`none == `selected)
	{
	    y2milestone ("selected patch: %1", patch);
	    if (patch["affects_pkg_manager"]:false)
	    {
		if (patch["reboot_needed"]:false)
		    ret	= `reboot;
		else if (ret != `reboot)
		    ret	= `restart_same_step;
	    }
	    else
	    {
		normal_patches = add (normal_patches, patch["name"]:"");
		// for this patch reboot would be needed, but still it is not
		// clear if the patch will be installed in this run -> save info
		if (patch["reboot_needed"]:false)
		    reboot_needed	= true;
	    }
	}
    });

    // unselect non-affects_pkg_manager patches and save them to file
    // for later usage
    if (ret != `auto && size (normal_patches) > 0)
    {
	foreach (string pname, normal_patches, {
	    Pkg::ResolvableNeutral (pname, `patch, true);
	});
	SCR::Write (.target.ycp, saved_path, normal_patches);
    }
    // no packagemanager patch selected ...
    if (ret == `auto)
    {
	// ... but there is a patch with "reboot_needed" flag (=probably kernel)
	if (reboot_needed)
	    ret     = `reboot;
	// ... and nothing to install -> skip the installation at all
	else if (normal_patches == [] && !Pkg::PkgAnyToInstall () &&
	    !Pkg::PkgAnyToDelete ())
	{
	    y2milestone ("no patch selected after all -> `next");
	    return `next;
	}
    }

    // if the package selector was not opened, ask to confirm licenses
    if (check_licenses)
    {
	foreach (string p, Pkg::GetPackages (`selected, true), {
	    string license = Pkg::PkgGetLicenseToConfirm (p);
	    if (license != nil && license != "")
	    {
		string rt_license = sformat ("<p><b>%1</b></p>\n%2", p, license);
		if (! Popup::AnyQuestionRichText (
		    // popup heading, with rich text widget and Yes/No buttons
		    _("Do you accept this license agreement?"),
		    rt_license,
		    70, 20,
		    Label::YesButton (), Label::NoButton (),
		    `focus_none))
		{
		    y2milestone("License not accepted: %1", p);
		    Pkg::ResolvableNeutral (p, `package, true);
		    neutralized	= add (neutralized, p);
		}
		else
		{
		    Pkg::PkgMarkLicenseConfirmed (p);
		}
	    }
	});
	if (neutralized != [])
	{
	    // now, neutralize also the patches related to neutralized packages
	    foreach (map patch, Pkg::ResolvableDependencies ("", `patch, ""), {
		if (patch["status"]:`none == `selected)
		{
		    foreach (map dep, (list<map>)patch["dependencies"]:[], {
			string kind	= dep["res_kind"]:"";
			string pname	= dep["name"]:"";
			pname	= substring (pname, 0, findfirstof (pname, " "));
			if ((kind == "package" || kind == "atom") &&
			    dep["dep_kind"]:"" == "requires" &&
			    contains (neutralized, pname))
			{
			    Pkg::ResolvableNeutral (patch["name"]:"", `patch, true);
			}
		    });
		}
	    });
	}
    }
    // install the patches
    OnlineUpdateCallbacks::RegisterOnlineUpdateCallbacks();
    WFM::call( "online_update_install" );

    if (ret == `reboot)
    {
	// message popup
	Popup::Message (_("The kernel has been updated. The system will
reboot now then continue the installation.
"));
    }
    else if (ret == `restart_same_step)
    {
	Popup::Message (OnlineUpdate::restart_message);
	SCR::Write (.target.ycp, restarted_path, 1);
    }

    if (!already_up)
    {
	Internet::Stop ("");

	if (i_set_demand)
	{
	    Internet::SetDemand (false);
	}
    }
    y2milestone ("result of inst_you: %1", ret);
    return ret;
}
